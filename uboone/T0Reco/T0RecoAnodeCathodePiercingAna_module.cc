////////////////////////////////////////////////////////////////////////
// Class:       T0RecoAnodeCathodePiercingAna
// Module Type: analyzer
// File:        T0RecoAnodeCathodePiercingAna_module.cc
//
// Generated at Wed Jul 13 20:22:39 2016 by David Caratelli using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// services etc...
#include "larcore/Geometry/Geometry.h"

// data-products
#include "lardata/RecoBase/Track.h"
#include "lardata/AnalysisBase/T0.h"
#include "lardata/MCBase/MCTrack.h"
#include "lardata/Utilities/AssociationUtil.h"

// C++
#include <memory>
#include <iostream>
#include <math.h>

// ROOT
#include <TTree.h>

class T0RecoAnodeCathodePiercingAna;

class T0RecoAnodeCathodePiercingAna : public art::EDAnalyzer {
public:
  explicit T0RecoAnodeCathodePiercingAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  T0RecoAnodeCathodePiercingAna(T0RecoAnodeCathodePiercingAna const &) = delete;
  T0RecoAnodeCathodePiercingAna(T0RecoAnodeCathodePiercingAna &&) = delete;
  T0RecoAnodeCathodePiercingAna & operator = (T0RecoAnodeCathodePiercingAna const &) = delete;
  T0RecoAnodeCathodePiercingAna & operator = (T0RecoAnodeCathodePiercingAna &&) = delete;

  void beginJob();

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  // Declare member data here.
  std::string fTrackProducer;
  std::string fT0Producer;
  double      fResolution; // cm resolution to allow mc-reco track matching. [Y,Z] must be within this distance

  TTree* _tree;
  double _mc_time;
  double _rc_time;
  int    _matched;

  bool MatchTracks(const recob::Track& track, const sim::MCTrack& mctrk, const double& res);

};


T0RecoAnodeCathodePiercingAna::T0RecoAnodeCathodePiercingAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  fTrackProducer = p.get<std::string>("TrackProducer");
  fT0Producer    = p.get<std::string>("T0Producer");
  fResolution    = p.get<double>("Resolution");
}

void T0RecoAnodeCathodePiercingAna::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;
  _tree = tfs->make<TTree>("_tree","T0 reco performance");
  _tree->Branch("_mc_time",&_mc_time,"mc_time/D");
  _tree->Branch("_rc_time",&_rc_time,"rc_time/D");
  _tree->Branch("_matched",&_matched,"matched/I");

  fResolution = 10; // cm

}

void T0RecoAnodeCathodePiercingAna::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  // load tracks previously created for which T0 reconstruction is requested
  art::Handle<std::vector<recob::Track> > track_h;
  e.getByLabel( fTrackProducer , track_h );
  
  // make sure tracks look good
  if(!track_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Track!"<<std::endl;
    throw std::exception();
  }

  // load MCtracks
  art::Handle<std::vector<sim::MCTrack> > mctrk_h;
  e.getByLabel("mcreco",mctrk_h);
  
  // make sure tracks look good
  if(!mctrk_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCTrack!"<<std::endl;
    throw std::exception();
  }

  // grab T0 objects associated with tracks
  art::FindMany<anab::T0> trk_t0_assn_v(track_h, e, fT0Producer );

  for (size_t i=0; i < track_h->size(); i++){

    auto const& track = track_h->at(i);

    _matched = 0;

    std::vector<const anab::T0*> T0_v = trk_t0_assn_v.at(i);

    // grab T0 object
    if (T0_v.size() == 1){

      auto t0 = T0_v.at(0);

      // reconstructed time comes from T0 object
      _rc_time = t0->Time();
      
      // loop through MCTracks to find the one that matches.
      for (size_t j=0; j < mctrk_h->size(); j++){
	
	auto const& mctrk = mctrk_h->at(j);

	// try matching to MC
	if (MatchTracks(track, mctrk, fResolution) == false)
	  continue;

	// matched -> get MCTrack time and reconstructed track reconstructed T0
	_mc_time = mctrk.at(0).T() / 1000.;
	_matched = 1;

      } // for all MCTracks

      _tree->Fill();
      
    } // if there is a reconstructed T0
    
  } // for all reconstructed tracks

}



bool T0RecoAnodeCathodePiercingAna::MatchTracks(const recob::Track& track, const sim::MCTrack& mctrk, const double& res)
{
  //assumes both the reco track
  //and mctrack are downwards going
  
  if ( (mctrk.size() < 2) or (track.NumberTrajectoryPoints() < 2) )
    return false;
  
  auto const& mctrk_s = mctrk.at(0);
  auto const& mctrk_e = mctrk.at( mctrk.size() - 1 );
  auto const& track_s = track.Vertex();
  auto const& track_e = track.End();
    
  // if track start is above and mctrk start is above
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) )
      return true;
  }
  // if tarck start is above and mctrk start is below
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is above
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z()-track_e.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is below
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) )
      return true;
  }
  
  return false;
}


DEFINE_ART_MODULE(T0RecoAnodeCathodePiercingAna)
