////////////////////////////////////////////////////////////////////////
// Class:       TestDBI
// Module Type: analyzer
// File:        TestDBI_module.cc
//
// Generated at Wed Feb 11 07:17:16 2015 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_08_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/TriggerData.h"
#include "larsimobj/Simulation/SimChannel.h"
#include "larcore/Geometry/Geometry.h"

#include "larevt/CalibrationDBI/Interface/DetPedestalService.h"
#include "larevt/CalibrationDBI/Interface/DetPedestalProvider.h"


// ROOT
#include "TH1D.h"
#include "TCanvas.h"

class TestDBI : public art::EDAnalyzer {
public:
  explicit TestDBI(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TestDBI(TestDBI const &) = delete;
  TestDBI(TestDBI &&) = delete;
  TestDBI & operator = (TestDBI const &) = delete;
  TestDBI & operator = (TestDBI &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  TH1D* fHist_Col;
  TH1D* fHist_Ind;
};


TestDBI::TestDBI(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
  fHist_Col(new TH1D("Collection","Collection",400, 350.0,550.0)),
  fHist_Ind(new TH1D("Induction" ,"Induction" ,400,2000.0,2200.0))
{}


void TestDBI::analyze(art::Event const & evt)
{

  art::ServiceHandle<geo::Geometry> geo;
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  evt.getByLabel("daq", digitVecHandle);
  for (auto iter = digitVecHandle->begin(); iter != digitVecHandle->end(); ++iter) {
    raw::RawDigit digit = *iter;
    unsigned int ch = digit.Channel();
    geo::SigType_t sigtype = geo->SignalType(ch);
    std::vector<short> rawadc(digit.Samples());
    raw::Uncompress(digit.ADCs(), rawadc, digit.Compression());
    
    double sum = 0;
    for (auto itADC = rawadc.begin(); itADC != rawadc.end(); ++itADC) {
      sum += *itADC;
    }
    
    sum /= digit.Samples();
    if (sigtype == geo::kCollection) {
      fHist_Col->Fill(sum);
    }
    else if (sigtype == geo::kInduction) {
      fHist_Ind->Fill(sum);
    }
  }//end loop over digits

  const lariov::DetPedestalProvider& pedestalRetrievalAlg = art::ServiceHandle<lariov::DetPedestalService>()->GetPedestalProvider();
  std::cout<<"PEDESTAL "<<pedestalRetrievalAlg.PedMean(8100)<<std::endl;   


  // Plot 
  TCanvas c("c","",600,500);
  fHist_Col->Draw();
  c.SaveAs("CollHist.png");
  fHist_Ind->Draw();
  c.SaveAs("IndHist.png");
}

DEFINE_ART_MODULE(TestDBI)
