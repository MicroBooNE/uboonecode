///////////////////////////////////////////////////////////////////////
// Class:       wirelengthtest
// Module Type: analyzer
// File:        wirelengthtest_module.cc
//
// Generated at Mon Aug 22 18:56:24 2016 by Adam Lister using artmod
// from cetpkgsupport v1_10_02.
//
// Pulls out raw::RawDigit information for validation of the data
// driven noise model
////////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes 
#include "lardataobj/RecoBase/Hit.h"
#include "larcore/Geometry/GeometryCore.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/sim.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "uboone/Utilities/SignalShapingServiceMicroBooNE.h"
#include "larcore/Geometry/CryostatGeo.h"
#include "larcore/Geometry/TPCGeo.h"
#include "larcore/Geometry/PlaneGeo.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h" // raw::ChannelID_t
#include "lardataobj/RecoBase/Wire.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusProvider.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusService.h"

// ROOT includes
#include "TTree.h"
#include "TFile.h"
#include "TH2.h"

// C++ includes
#include <iostream>
#include <fstream>

//class wirelengthtest;

class wirelengthtest : public art::EDAnalyzer {
public:
  explicit wirelengthtest(fhicl::ParameterSet const& p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  wirelengthtest(wirelengthtest const &) = delete;
  wirelengthtest(wirelengthtest &&) = delete;
  wirelengthtest & operator = (wirelengthtest const &) = delete;
  wirelengthtest & operator = (wirelengthtest &&) = delete;

  // Required functions.
  virtual void beginJob() override;
  virtual void beginRun(const art::Run& run) override;
  virtual void reconfigure(fhicl::ParameterSet const& parameterSet) override;
  virtual void analyze(const art::Event& e) override;

private:

  // Declare member data here.
  
  // parameters
  std::string fRawDLabel;
  std::string fRecobWire;
  // var
  int fEvent;
  int fRun;
  int fSubRun;
  
  float frWireLen;
  int frChannel;
  float frSigma;
  int frPlane;
  float frRMS_calc;

  double fPedestal;
  std::vector<short int> fRawADC;
  std::vector<short int> ADCNoPed;
  std::vector<int> tickno;
  
  int fRecobNSignal;
  int fRecobWireChannel;
  std::vector<int> wiretickno; 
  std::vector<float> signalvec; 
  
  // TTree
  TTree *ddntree;

};


wirelengthtest::wirelengthtest(fhicl::ParameterSet const& p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

  reconfigure(p);

}

//
// beginJob
//

void wirelengthtest::beginJob()
{

  art::ServiceHandle< art::TFileService > tfs;

  ddntree = tfs->make<TTree>("ddntree", "ddntree");

  // Define branches
  ddntree->Branch("Event", &fEvent, "Event/I");
  ddntree->Branch("Run", &fRun, "Run/I");
  ddntree->Branch("SubRun", &fSubRun, "SubRun/I");
  ddntree->Branch("WireLength", &frWireLen, "WireLength/F");
  ddntree->Branch("RawSigma", &frSigma, "RawSigma/F");
  ddntree->Branch("RawRMS_calc", &frRMS_calc, "RawRMS_Calc/F");
  ddntree->Branch("RawChannel", &frChannel, "Channel/I");
  ddntree->Branch("Plane", &frPlane, "Plane/I");
  ddntree->Branch("Pedestal", &fPedestal, "Pedestal/D");
  ddntree->Branch("RawADC", &fRawADC);
  ddntree->Branch("ADCNoPed", &ADCNoPed);
  ddntree->Branch("tickno", &tickno);

  ddntree->Branch("WireSignalVec", &signalvec);
  ddntree->Branch("WireNSignal", &fRecobNSignal, "WireNSignal/I");
  ddntree->Branch("WireChannel", &fRecobWireChannel, "WireChannel/I");
  ddntree->Branch("WireTickNo", &wiretickno);
}

//
// beginRun
//

void wirelengthtest::beginRun(const art::Run& /*run*/)
{}

//
// reconfigure
//

void wirelengthtest::reconfigure(fhicl::ParameterSet const& pset)
{

  fRawDLabel = pset.get< std::string > ("RawDLabel");
  fRecobWire = pset.get< std::string > ("recobWireLabel");
  
}

//
// analyze
//

void wirelengthtest::analyze(art::Event const & event)
{

  fEvent = event.id().event();
  fRun = event.run();
  fSubRun = event.subRun();

  // Implementation of required member function here.
 
  art::Handle< std::vector<raw::RawDigit> > rawDHandle;
  event.getByLabel(fRawDLabel, rawDHandle);

  art::Handle< std::vector<recob::Wire> > recobWireHandle;
  event.getByLabel(fRecobWire, recobWireHandle);

  for ( auto const& rawd : (*rawDHandle) ){

    frChannel = (int)rawd.Channel();

    // Grab Geom information for get Plane and WireLength info
    auto const* geom = lar::providerFrom<geo::Geometry>();
    std::vector<geo::WireID> wireIDs = geom->ChannelToWire(frChannel);
    geo::WireGeo const& wire = geom->Wire(wireIDs.front());
    
    frPlane = (int)wireIDs.front().Plane;
    frWireLen = wire.HalfL()*2;

    // Standard raw::RawDigit().GetSigma() method. Should return the RMS of the
    // ADCs but this DOES NOT WORK FOR THOSE DATA PRODUCTS PRODUCED AT DETSIM
    // LEVEL SUCH AS THE "daq" DIGITMODULELABEL. This also doesn't make any 
    // attempt to remove the signal to get at the RMS of the noise, meaning 
    // it gets a little bit screwed up.
    frSigma = rawd.GetSigma();

    // Manual calculation of RMS, removing signal (should be above the 84th 
    // percentile). This method also works for data products produced at 
    // DetSim level
    size_t fnticks = rawd.NADC();
    double adc;
    const std::vector<short int> adcv = rawd.ADCs();

    // Fill histogram with ADC values for each channel to use Quantile method.
    TH1F *h_adc = new TH1F("h_adc", "", 10000,0,10000);

    tickno.reserve( fnticks );
    //fRawADC.reserve( fnticks);
    ADCNoPed.reserve( fnticks );
    
    int it = 0;
    fPedestal = rawd.GetPedestal();
    for (size_t i=0; i < fnticks; i++)
    {
      adc = adcv.at(i);
      h_adc->Fill(adc);

      //std::cout << "tick " << i << " has adcv " << adc << std::endl; 
      //std::cout << "compressed: " << adc << " uncompressed: " << rawd.ADC(i) << std::endl;
      
      const lariov::ChannelStatusProvider& chanFilt = art::ServiceHandle<lariov::ChannelStatusService>()->GetProvider();

       if( (frChannel >= 1000 && frChannel < 1200) || (frChannel >=3500 && frChannel < 3700) || (frChannel >=6300 && frChannel < 6500)){
        if ( chanFilt.Status(frChannel) >= 3 ) {
        //fRawADC.push_back(adc);
        tickno.push_back(i);
        ADCNoPed.push_back(adc - fPedestal);

       }
        else if(chanFilt.Status(frChannel) < 3 && it == 0 ) {
        
          std::cout << " Problem! Channel " << frChannel << " is noisy or dead!" << std::endl;

        }
      }
    it++;
    }

    //std::cout << " finished adding to h_adc! " << std::endl;


    //Manual calculation of RMS on h_adc
    double pars[3];
    if (h_adc->GetSum()>0){
      double xc = 0.5-0.34;
      h_adc->GetQuantiles(1, &pars[0], &xc);

      xc = 0.5;
      h_adc->GetQuantiles(1, &pars[1], &xc);

      xc = 0.5+0.34;
      h_adc->GetQuantiles(1, &pars[2], &xc);

      frRMS_calc = sqrt((pow(pars[1]-pars[0],2) + pow(pars[2]-pars[1],2))/2.);

    }

    ddntree->Fill();
    delete h_adc;

    tickno.clear();
    ADCNoPed.clear();

  }
  
  for ( auto const& recobWire : (*recobWireHandle) ){
   
    fRecobNSignal = (int)recobWire.NSignal();
    fRecobWireChannel = (int)recobWire.Channel();
    const std::vector<float> signalv = recobWire.Signal();

    for (int i=0; i < fRecobNSignal; i++){
    
      wiretickno.push_back(i);
      signalvec.push_back(signalv.at(i)); 
    }

    ddntree->Fill();
    wiretickno.clear();
    signalvec.clear();
  }
}

DEFINE_ART_MODULE(wirelengthtest)
