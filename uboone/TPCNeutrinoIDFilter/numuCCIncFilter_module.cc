////////////////////////////////////////////////////////////////////////
// Class:       numuCCIncFilter
// Module Type: filter
// File:        numuCCIncFilter_module.cc
//
// Version by Lorena and John
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/Utilities/AssociationUtil.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include "larcore/CoreUtils/ServiceUtil.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larcore/Geometry/PlaneGeo.h"
#include "larcore/Geometry/WireGeo.h"
#include "lardata/Utilities/AssociationUtil.h"

#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/Vertex.h"
#include "lardata/RecoBase/OpFlash.h"
#include "lardata/AnalysisBase/CosmicTag.h"
#include "lardata/AnalysisBase/FlashMatch.h"
#include "lardata/AnalysisBase/T0.h"


class numuCCIncFilter;

class numuCCIncFilter : public art::EDFilter {
public:
    explicit numuCCIncFilter(fhicl::ParameterSet const & pset);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    
    // Plugins should not be copied or assigned.
    numuCCIncFilter(numuCCIncFilter const &) = delete;
    numuCCIncFilter(numuCCIncFilter &&) = delete;
    numuCCIncFilter & operator = (numuCCIncFilter const &) = delete;
    numuCCIncFilter & operator = (numuCCIncFilter &&) = delete;
    
    // Required functions.
    bool filter(art::Event & event) override;
    
    // Selected optional functions.
    void reconfigure(fhicl::ParameterSet const & pset) override;
    
    bool inFV(Double_t x, Double_t y, Double_t z) const;
    
    double FlashTrackDist(double flash, double start, double end) const;
    
private:
    
    std::string                fTrackModuleLabel;        ///< Producer of input tracks
    std::string                fVertexModuleLabel;       ///< Producer of input vertices
    std::string                fOpFlashModuleLabel;      ///< Producer of flashes
    
    double                     fDistToEdgeX;             ///< fiducial volume - x
    double                     fDistToEdgeY;             ///< fiducial volume - y
    double                     fDistToEdgeZ;             ///< fiducial volume - z
    
    double                     fFlashWidth;              ///< Cut on flash width
    double                     fBeamMin;                 ///< Cut on min beam time
    double                     fBeamMax;                 ///< Cut on max beam time
    double                     fPEThresh;                ///< Cut on PE threshold
    double                     fMinTrk2VtxDist;          ///< Minimum track to vertex distance
    double                     fMinTrackLen;             ///< Minimum track length
    
    geo::GeometryCore const*   fGeometry;                ///< pointer to the Geometry service
};

numuCCIncFilter::numuCCIncFilter(fhicl::ParameterSet const & pset) : fGeometry(lar::providerFrom<geo::Geometry>())
{
    this->reconfigure(pset);
    
    produces< art::Assns<recob::Vertex, recob::Track> >();
}

void numuCCIncFilter::reconfigure(fhicl::ParameterSet const & pset)
{
    
    fTrackModuleLabel        = pset.get<std::string> ("TrackModuleLabel");
    fVertexModuleLabel       = pset.get<std::string> ("VertexModuleLabel");
    fOpFlashModuleLabel      = pset.get<std::string> ("OpFlashModuleLabel");

    fDistToEdgeX             = fGeometry->DetHalfWidth()   - pset.get<double>("DistToEdgeX",   10.);
    fDistToEdgeY             = fGeometry->DetHalfHeight()  - pset.get<double>("DistToEdgeY",   20.);
    fDistToEdgeZ             = fGeometry->DetLength() / 2. - pset.get<double>("DistToEdgeZ",   10.);
    
    fFlashWidth              = pset.get<double>      ("FlashWidth",      80.);
    fBeamMin                 = pset.get<double>      ("BeamMin",        3.55);
    fBeamMax                 = pset.get<double>      ("BeamMax",        5.15);
    fPEThresh                = pset.get<double>      ("PEThresh",        50.);
    fMinTrk2VtxDist          = pset.get<double>      ("MinTrk2VtxDist",   5.);
    fMinTrackLen             = pset.get<double>      ("MinTrackLen",     75.);
}

//------------------------------------------------------------------------------------------------------------------------------------------
bool numuCCIncFilter::inFV(Double_t x, Double_t y, Double_t z) const
{
    double distInX = x - fGeometry->DetHalfWidth();
    double distInY = y - fGeometry->DetHalfHeight();
    double distInZ = z - 0.5 * fGeometry->DetLength();
    
    if (fabs(distInX) < fDistToEdgeX && fabs(distInY) < fDistToEdgeY && fabs(distInZ) < fDistToEdgeZ) return true;
    
    return false;
}

//This function returns the distance between a flash and
//a track (in one dimension, here used only for z direction)
double numuCCIncFilter::FlashTrackDist(double flash, double start, double end) const
{
    if(end >= start) {
        if(flash < end && flash > start) return 0;
        else return std::min(fabs(flash-start), fabs(flash-end));
    }
    else {
        if(flash > end && flash < start) return 0;
        else return std::min(fabs(flash-start), fabs(flash-end));
    }
}

bool numuCCIncFilter::filter(art::Event & event)
{
    bool pass = false;
    
    // Agreed convention is to ALWAYS output to the event store so get a pointer to our collection
    std::unique_ptr<art::Assns<recob::Vertex, recob::Track> > vertexTrackAssociations(new art::Assns<recob::Vertex, recob::Track>);
    
    // Recover the hanles to the vertex and track collections we want to analyze.
    art::Handle<std::vector<recob::Vertex>>  vertexVecHandle;
    art::Handle<std::vector<recob::Track>>   trackVecHandle;
    art::Handle<std::vector<recob::OpFlash>> flashListHandle;
    
    event.getByLabel(fVertexModuleLabel,    vertexVecHandle);
    event.getByLabel(fTrackModuleLabel,     trackVecHandle);
    
    //----------------------------------------------------
    std::vector<art::Ptr<recob::OpFlash> > flashlist;

    if (event.getByLabel(fOpFlashModuleLabel,flashListHandle))
        art::fill_ptr_vector(flashlist, flashListHandle);

    // Require valid handles, otherwise nothing to do
    if (vertexVecHandle.isValid() && vertexVecHandle->size() > 0 && trackVecHandle.isValid() && trackVecHandle->size() > 0)
    {
        //----loop over all the flashes and check if there are flashes within the beam
        //window and above the PE threshold
        const recob::OpFlash* flashPtr(0);
        double                flashmax(0);
        bool                  flashtag(false);
        
        for(const auto& opFlash : flashlist)
        {
            if (opFlash->Time() > fBeamMin && opFlash->Time() < fBeamMax && opFlash->TotalPE() > fPEThresh)
            {
                flashtag = true;
                
                // Keep track of the largest flash
                if (opFlash->TotalPE() > flashmax)
                {
                    flashPtr = opFlash.get();
                    flashmax = opFlash->TotalPE();
                }
            }
        }  //end of loop over all the flashes
        
        if(flashtag)
        {
            // We need to keep track of the best combination
            // Can we assign art ptrs? I don't think so...
            int    VertexCandidate=-1;
            int    TrackCandidate=-1;
            double TrackCandLength=0;
            double trackstartzcandidate=0;
            double trackstartxcandidate=0;
            double trackstartycandidate=0;
            double trackendzcandidate=0;
            double trackendxcandidate=0;
            double trackendycandidate=0;
            
            //-----------------------------------------------------------
            for(size_t vertexIdx = 0; vertexIdx < vertexVecHandle->size(); vertexIdx++)
            {
                // Recover art ptr to vertex
                art::Ptr<recob::Vertex> vertex(vertexVecHandle, vertexIdx);
                
                // Get the position of the vertex
                // Ultimately we really want the vertex position in a TVector3 object...
                double vertexXYZ[3];
                
                vertex->XYZ(vertexXYZ);
                
                TVector3 vertexPos(vertexXYZ[0],vertexXYZ[1],vertexXYZ[2]);
            	   
                if(inFV(vertexPos.X(),vertexPos.Y(),vertexPos.Z()))
                {
                    // For each vertex we loop over all tracks looking for matching pairs
                    // The outer loop here, then is over one less than all tracks
                    for(size_t trackIdx = 0; trackIdx < trackVecHandle->size(); trackIdx++)
                    {
                        // Work with an art Ptr here
                        art::Ptr<recob::Track> track(trackVecHandle,trackIdx);
                        
                        // so we need to get the track direction sorted out.
                        TVector3 trackPos = track->Vertex();
                        TVector3 trackEnd = track->End();
                        
                        // Take the closer end---------------------------------
                        double trackToVertexDist = (trackPos - vertexPos).Mag();
                        
                        if ((trackEnd - vertexPos).Mag() < trackToVertexDist)
                        {
                            trackPos          = track->End();
                            trackEnd          = track->Vertex();
                            trackToVertexDist = (trackPos - vertexPos).Mag();
                        }
                        
                        //--------------------------------------------------------------------------
                        if(trackToVertexDist<fMinTrk2VtxDist)
                        {
                            if((trackEnd-trackPos).Mag()>TrackCandLength)
                            {
                                TrackCandLength = (trackEnd-trackPos).Mag();
                                TrackCandidate=trackIdx;
                                VertexCandidate=vertexIdx;
                                trackstartzcandidate=trackPos.z();
                                trackstartxcandidate=trackPos.x();
                                trackstartycandidate=trackPos.y();
                                trackendzcandidate=trackEnd.z();
                                trackendxcandidate=trackEnd.x();
                                trackendycandidate=trackEnd.y();
                            }
                        } //end of if track distance is within 5cm
                    }  //end of loop over the tracks
                }  //end of if the vertex is contained
            } //end of loop over all the vertex
            
            if(TrackCandidate > -1)
            {
                bool trackContainedFlag = FlashTrackDist(flashPtr->ZCenter(), trackstartzcandidate, trackendzcandidate) < fFlashWidth;
            
                // Check to see if we think we have a candidate
                if(TrackCandLength>fMinTrackLen && trackContainedFlag && inFV(trackstartxcandidate, trackstartycandidate, trackstartzcandidate) && inFV(trackendxcandidate, trackendycandidate, trackendzcandidate) )
                {
                    // Make an association between the best vertex and the matching tracks
                    art::Ptr<recob::Vertex> vertex(vertexVecHandle,VertexCandidate);
                    art::Ptr<recob::Track>  track(trackVecHandle,TrackCandidate);
                    
                    util::CreateAssn(*this, event, track, vertex, *vertexTrackAssociations);
                
                    pass = true;
                }
            }
        }  //end of if flag
    }
    
    // Add associations to event.
    event.put(std::move(vertexTrackAssociations));
    
    return pass;
}//end filter 

DEFINE_ART_MODULE(numuCCIncFilter)








