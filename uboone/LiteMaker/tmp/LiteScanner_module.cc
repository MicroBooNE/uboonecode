////////////////////////////////////////////////////////////////////////
// Class:       LiteScanner
// Module Type: analyzer
// File:        LiteScanner_module.cc
//
// Generated at Wed Oct 15 18:41:39 2014 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

// ART includes
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArLite include
#include "DataFormat/storage_manager.h"

// LArSoft includes
#include "Geometry/Geometry.h"
#include "RawData/RawDigit.h"
#include "RecoBase/Wire.h"
#include "RecoBase/Hit.h"
#include "RecoBase/OpHit.h"
#include "RecoBase/OpFlash.h"
#include "RecoBase/Track.h"
#include "RecoBase/Cluster.h"
#include "RecoBase/SpacePoint.h"
#include "RecoBase/Shower.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/EndPoint2D.h"
#include "RecoBase/PFParticle.h"
#include "AnalysisBase/ParticleID.h"
#include "AnalysisBase/Calorimetry.h"
#include "AnalysisBase/CosmicTag.h"
#include "Simulation/SimChannel.h"
#include "SimulationBase/MCFlux.h"
#include "SimulationBase/GTruth.h"
#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"
#include "OpticalDetectorData/FIFOChannel.h"
#include "OpticalDetectorData/OpticalTypes.h"
#include "MCBase/MCShower.h"
#include "Utilities/LArProperties.h"
#include "Utilities/GeometryUtilities.h"
#include "Utilities/DetectorProperties.h"

// std 
#include <vector>
#include <string>
#include <iostream>

class LiteScanner;

class LiteScanner : public art::EDAnalyzer {
public:
  explicit LiteScanner(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LiteScanner(LiteScanner const &) = delete;
  LiteScanner(LiteScanner &&) = delete;
  LiteScanner & operator = (LiteScanner const &) = delete;
  LiteScanner & operator = (LiteScanner &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();

private:

  template<class T>
  std::map<art::Ptr<T>,std::pair<size_t,size_t> >* GetAssMap()
  { 
    throw cet::exception(__PRETTY_FUNCTION__) << "Called for an unimplemented type!";
    return nullptr;
  }
  
  // Utility function
  void event_init();

  //
  // Simple data product reader function
  //
  /// Function to read & store SimChannel data
  void ReadSimChannel(const art::Event& evt, const size_t name_index);
  /// Function to read & store reconstructed hit data
  void ReadHit(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed op-hit data
  void ReadOpHit(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed op-flash data
  void ReadOpFlash(const art::Event& evt,  const size_t name_index);
  /// Function to read & store calibrated wire data
  void ReadWire(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed cosmic-tag data
  void ReadCosmicTag(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed hit data
  void ReadCluster(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MC truth shower object
  void ReadMCShower(const art::Event& evt, const size_t name_index);
  /// Function to read & store spacepoints
  void ReadSpacePoint(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Tracking information
  void ReadTrack(const art::Event& evt,  const size_t name_index);
  /// Function to read & store GTruth information
  void ReadGTruth(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MCTruth information
  void ReadMCTruth(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MCFlux information
  void ReadMCFlux(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MCParticle information
  void ReadMCParticle(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Shower variables
  void ReadShower(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Calorimetry variables
  void ReadCalorimetry(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Vertex variables
  void ReadVertex(const art::Event& evt,  const size_t name_index);
  /// Function to read & store EndPoint2D variables
  void ReadEndPoint2D(const art::Event& evt,  const size_t name_index);
  /// Function to read & store ParticleID variables
  void ReadParticleID(const art::Event& evt,  const size_t name_index);
  /// Function to read & store PFParticle variables
  void ReadPFParticle(const art::Event& evt,  const size_t name_index);

  //
  // Association reader function
  //
  /// Cluster => X association
  void ReadClusterAssociation(const art::Event& evt,  const size_t name_index);
  /// SpacePoint => X association
  void ReadSpacePointAssociation(const art::Event& evt,  const size_t name_index);
  /// Track => X association
  void ReadTrackAssociation(const art::Event& evt,  const size_t name_index);
  /// CosmicTag => X association
  void ReadCosmicTagAssociation(const art::Event& evt,  const size_t name_index);
  /// Shower => X association
  void ReadShowerAssociation(const art::Event& evt,  const size_t name_index);
  /// Calorimetry => X association
  void ReadCalorimetryAssociation(const art::Event& evt,  const size_t name_index);
  /// Vertex => X association
  void ReadVertexAssociation(const art::Event& evt,  const size_t name_index);
  /// EP2D => X association
  void ReadEndPoint2DAssociation(const art::Event& evt,  const size_t name_index);
  /// Function to read & store ParticleID variables
  void ReadParticleIDAssociation(const art::Event& evt,  const size_t name_index);
  /// Function to read & store PFParticle variables
  void ReadPFParticleAssociation(const art::Event& evt,  const size_t name_index);

  // Declare member data here.
  ::larlite::storage_manager _mgr;
  // Module label holder
  std::vector<std::vector<std::string> > fModuleLabel_v;
  // Boolean holder to tell us whether specific producer's data is read or not
  std::vector<std::map<std::string,bool> > fDataReadFlag_v;
  // art::Ptr local storage. Value = index of data product & index of label
  std::map<art::Ptr<recob::Hit>,        std::pair<size_t,size_t> > fPtrIndex_hit;
  std::map<art::Ptr<recob::Cluster>,    std::pair<size_t,size_t> > fPtrIndex_cluster;
  std::map<art::Ptr<recob::Shower>,     std::pair<size_t,size_t> > fPtrIndex_shower;
  std::map<art::Ptr<recob::Vertex>,     std::pair<size_t,size_t> > fPtrIndex_vertex;
  std::map<art::Ptr<recob::Track>,      std::pair<size_t,size_t> > fPtrIndex_track;
  std::map<art::Ptr<anab::CosmicTag>,   std::pair<size_t,size_t> > fPtrIndex_cosmictag;
  std::map<art::Ptr<anab::Calorimetry>, std::pair<size_t,size_t> > fPtrIndex_calo;
  std::map<art::Ptr<recob::SpacePoint>, std::pair<size_t,size_t> > fPtrIndex_sps;
  std::map<art::Ptr<recob::EndPoint2D>, std::pair<size_t,size_t> > fPtrIndex_end2d;
  std::map<art::Ptr<recob::Vertex>,     std::pair<size_t,size_t> > fPtrIndex_vtx;
  std::map<art::Ptr<anab::ParticleID>,  std::pair<size_t,size_t> > fPtrIndex_partid;
  std::map<art::Ptr<recob::PFParticle>, std::pair<size_t,size_t> > fPtrIndex_pfpart;
};


LiteScanner::LiteScanner(fhicl::ParameterSet const & p) 
  : EDAnalyzer(p)
  , fModuleLabel_v  ((size_t)(::larlite::data::kDATA_TYPE_MAX),std::vector<std::string>())
  , fDataReadFlag_v ((size_t)(::larlite::data::kDATA_TYPE_MAX),std::map<std::string,bool>())
  
 // More initializers here.
{
  //  fDataReadFlag.resize((size_t)(::larlite::data::kDATA_TYPE_MAX),std::map<std::string,
		       
  for(size_t i = 0; i<(size_t)(::larlite::data::kDATA_TYPE_MAX); ++i) {

    std::vector<std::string> labels;
    switch((::larlite::data::DataType_t)i) {
    case ::larlite::data::kUndefined:
    case ::larlite::data::kEvent:
      fModuleLabel_v[i] = labels;
      break;
    default:
      labels = p.get<std::vector<std::string> >(::larlite::data::kDATA_TREE_NAME[i].c_str(),labels);
      fModuleLabel_v[i] = labels;
      for(auto const& label : labels)
	fDataReadFlag_v[i].insert(std::make_pair(label,false));
    }
  }  
}

void LiteScanner::beginJob() {
  //_mgr.set_verbosity(larlite::msg::kDEBUG);
  _mgr.set_out_filename("larlite.root");
  _mgr.set_io_mode(::larlite::storage_manager::kWRITE);
  _mgr.open();
}

void LiteScanner::endJob() {
  _mgr.close();
}

void LiteScanner::event_init()
{
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    for(auto& name_bool : fDataReadFlag_v[i])

      name_bool.second = false;

  }
  fPtrIndex_hit.clear();
  fPtrIndex_cluster.clear();
  fPtrIndex_shower.clear();
  fPtrIndex_vertex.clear();
  fPtrIndex_cosmictag.clear();
  fPtrIndex_track.clear();
  fPtrIndex_calo.clear();
  fPtrIndex_sps.clear();
  fPtrIndex_end2d.clear();
  fPtrIndex_vtx.clear();
}

void LiteScanner::analyze(art::Event const & e)
{

  event_init();

  //
  // Loop over data type to store data & locally art::Ptr
  //
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    auto label_v = fModuleLabel_v[i];
    ::larlite::data::DataType_t lite_type = (::larlite::data::DataType_t)i;

    for(size_t j=0; j<label_v.size(); ++j) {

      switch(lite_type) {
      case ::larlite::data::kSimChannel:
	ReadSimChannel(e,j); break;
      case ::larlite::data::kMCShower:
	ReadMCShower(e,j); break;
      case ::larlite::data::kWire:
	ReadWire(e,j); break;
      case ::larlite::data::kHit:
	ReadHit(e,j); break;
      case ::larlite::data::kOpHit:
	ReadOpHit(e,j); break;
      case ::larlite::data::kOpFlash:
	ReadOpFlash(e,j); break;
      case ::larlite::data::kCluster:
	ReadCluster(e,j); break;
      case ::larlite::data::kCosmicTag:
	ReadCosmicTag(e,j); break;
      case ::larlite::data::kEndPoint2D:
	ReadEndPoint2D(e,j); break;
      case ::larlite::data::kSpacePoint:
	ReadSpacePoint(e,j); break;
      case ::larlite::data::kTrack:
	ReadTrack(e,j); break;
      case ::larlite::data::kShower:
	ReadShower(e,j); break;
      case ::larlite::data::kVertex:
	ReadVertex(e,j); break;
      case ::larlite::data::kGTruth:
	ReadGTruth(e,j); break;
      case ::larlite::data::kMCTruth:
	ReadMCTruth(e,j); break;
      case ::larlite::data::kMCFlux:
	ReadMCFlux(e,j); break;
      case ::larlite::data::kMCParticle:
	ReadMCParticle(e,j); break;
      case ::larlite::data::kCalorimetry:
	ReadCalorimetry(e,j); break;
      case ::larlite::data::kParticleID:
	ReadParticleID(e,j); break;
      case ::larlite::data::kPFParticle:
	ReadPFParticle(e,j); break;
      case ::larlite::data::kUndefined:
      case ::larlite::data::kEvent:
      default:
	continue;
      }
      auto lite_data = _mgr.get_data(lite_type,label_v[j]);
      lite_data->set_run      ( e.id().run()    );
      lite_data->set_subrun   ( e.id().subRun() );
      lite_data->set_event_id ( e.id().event()  );
    }
  }

  //
  // Loop over data type to store association
  //
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    auto label_v = fModuleLabel_v[i];
    ::larlite::data::DataType_t lite_type = (::larlite::data::DataType_t)i;

    for(size_t j=0; j<label_v.size(); ++j) {

      switch(lite_type) {
      case ::larlite::data::kCluster:
	ReadClusterAssociation(e,j); break;
      case ::larlite::data::kCosmicTag:
	ReadCosmicTagAssociation(e,j); break;
      case ::larlite::data::kEndPoint2D:
	ReadEndPoint2DAssociation(e,j); break;
      case ::larlite::data::kSpacePoint:
	ReadSpacePointAssociation(e,j); break;
      case ::larlite::data::kTrack:
	ReadTrackAssociation(e,j); break;
      case ::larlite::data::kShower:
	ReadShowerAssociation(e,j); break;
      case ::larlite::data::kVertex:
	ReadVertexAssociation(e,j); break;
      case ::larlite::data::kCalorimetry:
	ReadCalorimetryAssociation(e,j); break;
      case ::larlite::data::kParticleID:
	ReadParticleIDAssociation(e,j); break;
      case ::larlite::data::kPFParticle:
	ReadPFParticleAssociation(e,j); break;
	// Currently associations FROM the followings are not supported
      case ::larlite::data::kMCTruth:
      case ::larlite::data::kMCParticle:
      case ::larlite::data::kOpHit:
      case ::larlite::data::kOpFlash:
      case ::larlite::data::kSimChannel:
      case ::larlite::data::kMCShower:
      case ::larlite::data::kWire:
      case ::larlite::data::kHit:
      case ::larlite::data::kUndefined:
      case ::larlite::data::kEvent:
      default:
	continue;
      }
    }
  }
  _mgr.next_event();
}

//-------------------------------------------------------------------------------------------------
// SimChannel
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadSimChannel(const art::Event& evt, const size_t name_index)
{ 
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSimChannel)][name_index];
  auto lite_data = (::larlite::event_simch*)(_mgr.get_data(::larlite::data::kSimChannel,mod_name));
  art::Handle<std::vector<sim::SimChannel> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kSimChannel)][mod_name] = true;  
  for(size_t i=0; i<dh->size(); ++i ) {
    
    const art::Ptr<sim::SimChannel> sch_ptr(dh,i);
    
    std::map<unsigned short,std::vector<sim::IDE> > sch_map(sch_ptr->TDCIDEMap());
    
    larlite::simch lite_sch;
    lite_sch.set_channel(sch_ptr->Channel());
    
    for(auto sch_iter = sch_map.begin(); sch_iter!=sch_map.end(); ++sch_iter) {
      
      unsigned short tdc = (*sch_iter).first;
      
      for(auto const this_ide : (*sch_iter).second) {
	
	larlite::ide lite_ide;
	lite_ide.trackID = this_ide.trackID;
	lite_ide.numElectrons = this_ide.numElectrons;
	lite_ide.energy = this_ide.energy;
	lite_ide.x = this_ide.x;
	lite_ide.y = this_ide.y;
	lite_ide.z = this_ide.z;
	
	lite_sch.add_ide(tdc,lite_ide);
      }
    }
    
    lite_data->push_back(lite_sch);
  }
  
}

//-------------------------------------------------------------------------------------------------
// Wire
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadWire(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kWire)][name_index];
  auto lite_data = (::larlite::event_wire*)(_mgr.get_data(::larlite::data::kWire,mod_name));
  art::Handle<std::vector<recob::Wire> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kWire)][mod_name] = true;
  for(size_t i=0; i<dh->size(); i++){

    const art::Ptr<recob::Wire> wire_ptr(dh,i);
    
    larlite::wire wire_lite(wire_ptr->Signal(),
			    wire_ptr->Channel(),
			    (larlite::geo::View_t)(wire_ptr->View()),
			    (larlite::geo::SigType_t)(wire_ptr->SignalType()));

    lite_data->push_back(wire_lite);
  }  
}

//-------------------------------------------------------------------------------------------------
// Hit
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadHit(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kHit)][name_index];
  auto lite_data = (::larlite::event_hit*)(_mgr.get_data(::larlite::data::kHit,mod_name));
  art::Handle<std::vector<recob::Hit> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  art::ServiceHandle<geo::Geometry> geo;
  fDataReadFlag_v[(size_t)(::larlite::data::kHit)][mod_name] = true;
  for(size_t i=0; i<dh->size(); i++){
      
    art::Ptr<recob::Hit> hit_ptr(dh,i);
    
    larlite::hit lite_hit;
    
    lite_hit.set_waveform(hit_ptr->fHitSignal);
    lite_hit.set_times(hit_ptr->StartTime(),
			hit_ptr->PeakTime(),
			hit_ptr->EndTime());
    lite_hit.set_times_err(hit_ptr->SigmaStartTime(),
			    hit_ptr->SigmaPeakTime(),
			    hit_ptr->SigmaEndTime());
    lite_hit.set_charge(hit_ptr->Charge(),hit_ptr->Charge(true));
    lite_hit.set_charge_err(hit_ptr->SigmaCharge(),hit_ptr->SigmaCharge(true));
    lite_hit.set_multiplicity(hit_ptr->Multiplicity());
    lite_hit.set_channel(geo->PlaneWireToChannel(hit_ptr->WireID()));
    //lite_hit.set_channel(hit_ptr->Channel());
    lite_hit.set_wire(hit_ptr->WireID().Wire);
    lite_hit.set_fit_goodness(hit_ptr->GoodnessOfFit());
    lite_hit.set_view((larlite::geo::View_t)(hit_ptr->View()));
    lite_hit.set_sigtype((larlite::geo::SigType_t)(hit_ptr->SignalType()));
    
    // Store address map for downstream association
    fPtrIndex_hit[hit_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_hit);
    
  }
}

//-------------------------------------------------------------------------------------------------
// Cluster
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCluster(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCluster)][name_index];
  auto lite_data = (::larlite::event_cluster*)(_mgr.get_data(::larlite::data::kCluster,mod_name));
  art::Handle<std::vector<recob::Cluster> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kCluster)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {
    
    art::Ptr<recob::Cluster> cluster_ptr(dh,i);
      
    larlite::cluster lite_cluster;
    lite_cluster.set_charge(cluster_ptr->Charge());
    lite_cluster.set_dtdw(cluster_ptr->dTdW());
    lite_cluster.set_dqdw(cluster_ptr->dQdW());
    lite_cluster.set_dtdw_err(cluster_ptr->SigmadTdW());
    lite_cluster.set_dqdw_err(cluster_ptr->SigmadQdW());
    lite_cluster.set_id(cluster_ptr->ID());
    lite_cluster.set_view((larlite::geo::View_t)(cluster_ptr->View()));
    lite_cluster.set_start_vtx(cluster_ptr->StartPos());
    lite_cluster.set_end_vtx(cluster_ptr->EndPos());
    lite_cluster.set_start_vtx_err(cluster_ptr->SigmaStartPos());
    lite_cluster.set_end_vtx_err(cluster_ptr->SigmaEndPos());
    
    // Store address map for downstream association
    fPtrIndex_cluster[cluster_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_cluster);
  }
}

void LiteScanner::ReadClusterAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCluster)][name_index];
  art::Handle<std::vector<recob::Cluster> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  //
  // Cluster=>Hit association
  //
  // Only store if any hit is stored
  std::vector<larlite::AssSet_t> ass_set_v(fModuleLabel_v[(size_t)(::larlite::data::kHit)].size());
  if(ass_set_v.size()) {

    auto lite_data = _mgr.get_data(::larlite::data::kCluster,mod_name);
    art::FindManyP<recob::Hit> hit_m(dh, evt, mod_name);

    for(size_t i=0; i<dh->size(); ++i) {

      const std::vector<art::Ptr<recob::Hit> > hit_ptr_v = hit_m.at(i);

      std::vector<larlite::AssUnit_t> ass_unit_v(ass_set_v.size());

      for(auto& hit_ptr : hit_ptr_v) {

	auto info_iter = fPtrIndex_hit.find(hit_ptr);

	if(info_iter == fPtrIndex_hit.end()) continue;

	auto data_index = (*info_iter).second.first;
	auto name_index = (*info_iter).second.second;

	ass_unit_v.at(name_index).push_back(data_index);
      }
      for(size_t i=0; i<ass_set_v.size(); ++i)

	ass_set_v[i].push_back(ass_unit_v[i]);

    } // end looping over clusters
	
    // Store associations to hits if there's any found
    for(size_t i=0; i<ass_set_v.size(); ++i) {

      // Loop over in one association set, store if there's any
      for(auto const& ass_unit : ass_set_v[i]) {

	if(ass_unit.size()) {

	  auto ass_name = fModuleLabel_v[(size_t)(::larlite::data::kHit)][i];

	  larlite::product_id type(::larlite::data::kHit,ass_name);

	  lite_data->set_association(type,ass_set_v[i]);

	  break;
	}
      }// end looping over association set
    }// end looping over a vector of association set
  }// end storing Cluster=>Hit association
}

//-------------------------------------------------------------------------------------------------
// OpHit
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadOpHit(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kOpHit)][name_index];
  auto lite_data = (::larlite::event_ophit*)(_mgr.get_data(::larlite::data::kOpHit,mod_name));
  art::Handle<std::vector<recob::OpHit> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kOpHit)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<recob::OpHit> hit_ptr(dh,i);

    ::larlite::ophit lite_hit( hit_ptr->OpChannel(),
			       hit_ptr->PeakTime(),
			       hit_ptr->PeakTimeAbs(),
			       hit_ptr->Frame(),
			       hit_ptr->Width(),
			       hit_ptr->Area(),
			       hit_ptr->Amplitude(),
			       hit_ptr->PE(),
			       hit_ptr->FastToTotal() );
    
    lite_data->push_back(lite_hit);
  }
}

//-------------------------------------------------------------------------------------------------
// OpFlash
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadOpFlash(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kOpFlash)][name_index];
  auto lite_data = (::larlite::event_opflash*)(_mgr.get_data(::larlite::data::kOpFlash,mod_name));
  art::Handle<std::vector<recob::OpFlash> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  art::ServiceHandle<geo::Geometry> geo;
  fDataReadFlag_v[(size_t)(::larlite::data::kOpFlash)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<recob::OpFlash> flash_ptr(dh,i);

    std::vector<double> pe_per_opdet;
    pe_per_opdet.reserve(geo->NOpChannels());
    for(size_t j=0; j<geo->NOpChannels(); ++j)
      pe_per_opdet.push_back(flash_ptr->PE(j));

    ::larlite::opflash lite_flash( flash_ptr->Time(),
				   flash_ptr->TimeWidth(),
				   flash_ptr->AbsTime(),
				   flash_ptr->Frame(),
				   pe_per_opdet,
				   flash_ptr->InBeamFrame(),
				   flash_ptr->OnBeamTime(),
				   flash_ptr->FastToTotal(),
				   flash_ptr->YCenter(),
				   flash_ptr->YWidth(),
				   flash_ptr->ZCenter(),
				   flash_ptr->ZWidth(),
				   flash_ptr->WireCenters(),
				   flash_ptr->WireWidths());
    
    lite_data->push_back(lite_flash);
  }

}

//-------------------------------------------------------------------------------------------------
// CosmicTag
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCosmicTag(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCosmicTag)][name_index];
  auto lite_data = (::larlite::event_cosmictag*)(_mgr.get_data(::larlite::data::kCosmicTag,mod_name));
  art::Handle<std::vector<anab::CosmicTag> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;
  fDataReadFlag_v[(size_t)(::larlite::data::kCosmicTag)][mod_name] = true;

  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<anab::CosmicTag> tag_ptr(dh,i);

    larlite::cosmictag lite_tag(tag_ptr->endPt1,
				tag_ptr->endPt2,
				tag_ptr->fCosmicScore,
				(::larlite::anab::CosmicTagID_t)(tag_ptr->fCosmicType));

    // store product ptr for association
    fPtrIndex_cosmictag[tag_ptr] = std::make_pair(lite_data->size(),name_index);

    lite_data->push_back(lite_tag);
    
  }
}

void LiteScanner::ReadCosmicTagAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCosmicTag)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kCosmicTag,mod_name));
  art::Handle<std::vector<anab::CosmicTag> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// SpacePoint
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadSpacePoint(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSpacePoint)][name_index];
  auto lite_data = (::larlite::event_spacepoint*)(_mgr.get_data(::larlite::data::kSpacePoint,mod_name));
  art::Handle<std::vector<recob::SpacePoint> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kSpacePoint)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {
    
    art::Ptr<recob::SpacePoint> spacepoint_ptr(dh,i);
      
    larlite::spacepoint lite_spacepoint(spacepoint_ptr->ID(),
					spacepoint_ptr->XYZ()[0],
					spacepoint_ptr->XYZ()[1],
					spacepoint_ptr->XYZ()[2],
					spacepoint_ptr->ErrXYZ()[0],
					spacepoint_ptr->ErrXYZ()[1],
					spacepoint_ptr->ErrXYZ()[2],
					spacepoint_ptr->Chisq() );
    
    // Store address map for downstream association
    fPtrIndex_sps[spacepoint_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_spacepoint);
  }

}

void LiteScanner::ReadSpacePointAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSpacePoint)][name_index];
  art::Handle<std::vector<recob::SpacePoint> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;
  
}

//-------------------------------------------------------------------------------------------------
// Track
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadTrack(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kTrack)][name_index];
  auto lite_data = (::larlite::event_track*)(_mgr.get_data(::larlite::data::kTrack,mod_name));
  art::Handle<std::vector<recob::Track> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kTrack)][mod_name] = true;

  for(size_t i=0; i<dh->size(); ++i) {
    
    art::Ptr<recob::Track> track_ptr(dh,i);
      
    larlite::track track_lite;
    track_lite.set_track_id ( track_ptr->ID()   );
    // Direction & points
    for(size_t i=0; i<track_ptr->NumberTrajectoryPoints(); i++) {
      track_lite.add_vertex     (track_ptr->LocationAtPoint(i));
      track_lite.add_direction  (track_ptr->DirectionAtPoint(i));
      }
    // Covariance
    for(size_t i=0; i<track_ptr->NumberCovariance(); i++)
	track_lite.add_covariance (track_ptr->CovarianceAtPoint(i));
    // Momentum
    for(size_t i=0; i<track_ptr->NumberFitMomentum(); i++)
      track_lite.add_momentum   (track_ptr->MomentumAtPoint(i));

    // Store address map for downstream association
    fPtrIndex_track[track_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(track_lite);
  }

}

void LiteScanner::ReadTrackAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kTrack)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kTrack,mod_name));
  art::Handle<std::vector<recob::Track> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Shower
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadShower(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kShower)][name_index];
  auto lite_data = (::larlite::event_shower*)(_mgr.get_data(::larlite::data::kShower,mod_name));
  art::Handle<std::vector<recob::Shower> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kShower)][mod_name] = true;

  for(size_t i=0; i<dh->size(); ++i) {
    
    const art::Ptr<recob::Shower> shower_ptr(dh,i);

    larlite::shower lite_shower;

    lite_shower.set_id(shower_ptr->ID());
    //light_shower.set_total_charge(shower_ptr->TotalCharge());
    lite_shower.set_direction(shower_ptr->Direction());
    lite_shower.set_direction_err(shower_ptr->DirectionErr());
    //light_shower.set_max_width(shower_ptr->MaxWidthX(),shower_ptr->MaxWidthY());
    //light_shower.set_distance_max_width(shower_ptr->DistanceMaxWidth());
    
    fPtrIndex_shower[shower_ptr] = std::make_pair(lite_data->size(),name_index);

    lite_data->push_back(lite_shower);
  }

}

void LiteScanner::ReadShowerAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kShower)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kShower,mod_name));
  art::Handle<std::vector<recob::Shower> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// EndPoint2D
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadEndPoint2D(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kEndPoint2D)][name_index];
  auto lite_data = (::larlite::event_endpoint2d*)(_mgr.get_data(::larlite::data::kEndPoint2D,mod_name));
  art::Handle<std::vector<recob::EndPoint2D> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kEndPoint2D)][mod_name] = true;
  for(size_t i=0; i < dh->size(); ++i) {
    
    const art::Ptr<recob::EndPoint2D> end2d_ptr(dh,i);
    
    // get vertex info
    larlite::endpoint2d lite_end2d(end2d_ptr->DriftTime(),
				   end2d_ptr->WireID().Wire,
				   end2d_ptr->Strength(),
				   end2d_ptr->ID(),
				   (larlite::geo::View_t)(end2d_ptr->View()),
				   end2d_ptr->Charge());

    fPtrIndex_end2d[end2d_ptr] = std::make_pair(lite_data->size(),name_index);
    
    // Store data
    lite_data->push_back(lite_end2d);
  }
  
}

void LiteScanner::ReadEndPoint2DAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kEndPoint2D)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kEndPoint2D,mod_name));
  art::Handle<std::vector<recob::EndPoint2D> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Vertex
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadVertex(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kVertex)][name_index];
  auto lite_data = (::larlite::event_vertex*)(_mgr.get_data(::larlite::data::kVertex,mod_name));
  art::Handle<std::vector<recob::Vertex> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kVertex)][mod_name] = true;
  Double_t xyz[3]={0};
  
  for(size_t i=0; i < dh->size(); ++i) {

    const art::Ptr<recob::Vertex> vtx_ptr(dh,i);

    vtx_ptr->XYZ(xyz);

    // get vertex info
    larlite::vertex lite_vtx(xyz,
			      vtx_ptr->ID());

    fPtrIndex_vtx[vtx_ptr] = std::make_pair(lite_data->size(),name_index);

    // Store data
    lite_data->push_back(lite_vtx);
    
  }
  
}

void LiteScanner::ReadVertexAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kVertex)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kVertex,mod_name));
  art::Handle<std::vector<recob::Vertex> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// ParticleID
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadParticleID(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kParticleID)][name_index];
  auto lite_data = (::larlite::event_partid*)(_mgr.get_data(::larlite::data::kParticleID,mod_name));
  art::Handle<std::vector<anab::ParticleID> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;
  fDataReadFlag_v[(size_t)(::larlite::data::kParticleID)][mod_name] = true;
  
  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<anab::ParticleID> partid_ptr(dh,i);

    larlite::partid lite_partid( partid_ptr->Pdg(),
				 partid_ptr->Ndf(),
				 partid_ptr->MinChi2(),
				 partid_ptr->DeltaChi2(),
				 partid_ptr->Chi2Proton(),
				 partid_ptr->Chi2Kaon(),
				 partid_ptr->Chi2Pion(),
				 partid_ptr->Chi2Muon(),
				 partid_ptr->MissingE(),
				 partid_ptr->MissingEavg(),
				 partid_ptr->PIDA() );

    fPtrIndex_partid[partid_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_partid);
  }

}

void LiteScanner::ReadParticleIDAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kParticleID)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kParticleID,mod_name));
  art::Handle<std::vector<anab::ParticleID> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// PFParticle
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadPFParticle(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kPFParticle)][name_index];
  auto lite_data = (::larlite::event_pfpart*)(_mgr.get_data(::larlite::data::kPFParticle,mod_name));
  art::Handle<std::vector<recob::PFParticle> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;
  fDataReadFlag_v[(size_t)(::larlite::data::kPFParticle)][mod_name] = true;

  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<recob::PFParticle> pfpart_ptr(dh,i);

    larlite::pfpart lite_pfpart(pfpart_ptr->PdgCode(),
				pfpart_ptr->Self(),
				pfpart_ptr->Parent(),
				pfpart_ptr->Daughters());

    fPtrIndex_pfpart[pfpart_ptr] = std::make_pair(lite_data->size(),name_index);

    lite_data->push_back(lite_pfpart);
  }

}

void LiteScanner::ReadPFParticleAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kPFParticle)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kPFParticle,mod_name));
  art::Handle<std::vector<recob::PFParticle> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

}

//-------------------------------------------------------------------------------------------------
// Calorimetry
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCalorimetry(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCalorimetry)][name_index];
  auto lite_data = (::larlite::event_calorimetry*)(_mgr.get_data(::larlite::data::kCalorimetry,mod_name));
  art::Handle<std::vector<anab::Calorimetry> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kCalorimetry)][mod_name] = true;
  for(size_t i=0; i < dh->size(); ++i) {
    
    const art::Ptr<anab::Calorimetry> calo_ptr(dh,i);
      
    larlite::calorimetry lite_calo;

    lite_calo.set_dedx(calo_ptr->dEdx());
    lite_calo.set_dqdx(calo_ptr->dQdx());
    lite_calo.set_residual_range(calo_ptr->ResidualRange());
    lite_calo.set_deadwire_range(calo_ptr->DeadWireResRC());
    lite_calo.set_kinetic_energy(calo_ptr->KineticEnergy());
    lite_calo.set_range(calo_ptr->Range());
    lite_calo.set_track_pitch(calo_ptr->TrkPitchVec());

    fPtrIndex_calo[calo_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_calo);

  }

}

void LiteScanner::ReadCalorimetryAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCalorimetry)][name_index];
  //auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kCalorimetry,mod_name));
  art::Handle<std::vector<anab::Calorimetry> > dh;
  evt.getByLabel(mod_name,dh);
  //std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// GTruth
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadGTruth(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kGTruth)][name_index];
  auto lite_data = (::larlite::event_gtruth*)(_mgr.get_data(::larlite::data::kGTruth,mod_name));
  art::Handle<std::vector<simb::GTruth> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kGTruth)][mod_name] = true;

  for(size_t i=0; i<dh->size(); ++i) {

    const art::Ptr<simb::GTruth> gtruth_ptr(dh,i);

    larlite::gtruth lite_gtruth;

    lite_gtruth.fGint        = gtruth_ptr->fGint;
    lite_gtruth.fGscatter    = gtruth_ptr->fGscatter;
    lite_gtruth.fweight      = gtruth_ptr->fweight;
    lite_gtruth.fprobability = gtruth_ptr->fprobability;
    lite_gtruth.fXsec        = gtruth_ptr->fXsec;
    lite_gtruth.fDiffXsec    = gtruth_ptr->fDiffXsec;
    lite_gtruth.fNumPiPlus   = gtruth_ptr->fNumPiPlus;
    lite_gtruth.fNumPiMinus  = gtruth_ptr->fNumPiMinus;
    lite_gtruth.fNumPi0      = gtruth_ptr->fNumPi0;
    lite_gtruth.fNumProton   = gtruth_ptr->fNumProton;
    lite_gtruth.fNumNeutron  = gtruth_ptr->fNumNeutron;
    lite_gtruth.fIsCharm     = gtruth_ptr->fIsCharm;
    lite_gtruth.fResNum      = gtruth_ptr->fResNum;
    lite_gtruth.fgQ2         = gtruth_ptr->fgQ2;
    lite_gtruth.fgq2         = gtruth_ptr->fgq2;
    lite_gtruth.fgW          = gtruth_ptr->fgW;
    lite_gtruth.fgT          = gtruth_ptr->fgT;
    lite_gtruth.fgX          = gtruth_ptr->fgX;
    lite_gtruth.fgY          = gtruth_ptr->fgY;
    lite_gtruth.fFShadSystP4 = gtruth_ptr->fFShadSystP4;
    lite_gtruth.fIsSeaQuark  = gtruth_ptr->fIsSeaQuark;
    lite_gtruth.fHitNucP4    = gtruth_ptr->fHitNucP4;
    lite_gtruth.ftgtZ        = gtruth_ptr->ftgtZ;
    lite_gtruth.ftgtA        = gtruth_ptr->ftgtA;
    lite_gtruth.ftgtPDG      = gtruth_ptr->ftgtPDG;

    lite_data->push_back(lite_gtruth);

  }

}

//-------------------------------------------------------------------------------------------------
// MCFlux
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCFlux(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCFlux)][name_index];
  auto lite_data = (::larlite::event_mcflux*)(_mgr.get_data(::larlite::data::kMCFlux,mod_name));
  art::Handle<std::vector<simb::MCFlux> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kMCFlux)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    const art::Ptr<simb::MCFlux> mcflux_ptr(dh,i);

    larlite::mcflux lite_mcflux;

    lite_data->push_back(lite_mcflux);
  }

}

//-------------------------------------------------------------------------------------------------
// MCTruth
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCTruth(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCTruth)][name_index];
  auto lite_data = (::larlite::event_mctruth*)(_mgr.get_data(::larlite::data::kMCTruth,mod_name));
  art::Handle<std::vector<simb::MCTruth> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kMCTruth)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    const art::Ptr<simb::MCTruth> mct_ptr(dh,i);
    
    larlite::mctruth lite_mct;
    
    // Generator (Origin) ID
    lite_mct.SetOrigin((larlite::mc::Origin_t) mct_ptr->Origin() );

    // Particle Information
    for(size_t j=0; j<(size_t)(mct_ptr->NParticles()); ++j) {

      const simb::MCParticle lar_part(mct_ptr->GetParticle(j));
      
      larlite::mcpart lite_part(lar_part.TrackId(),
				lar_part.PdgCode(),
				lar_part.Process(), 
				lar_part.Mother(),
				lar_part.Mass(),
				lar_part.StatusCode());
      
      lite_part.SetPolarization(lar_part.Polarization());
      lite_part.SetRescatter(lar_part.Rescatter());
      lite_part.SetWeight(lar_part.Weight());
      
      for(size_t k=0; k<(size_t)(lar_part.NumberDaughters()); ++k)
	
	lite_part.AddDaughter(lar_part.Daughter(k));

      // Add trajectory points
      larlite::mctrajectory lite_track;
      lite_track.reserve(lar_part.NumberTrajectoryPoints());
      
      bool   loopInFV=false;
      size_t start_FV=0;
      for(size_t l=0; l<(size_t)lar_part.NumberTrajectoryPoints(); ++l) {
	
	lite_track.push_back(lar_part.Position(l),lar_part.Momentum(l));
	
	// Record fiducial volume tracking
	bool inFV = false;//IsFV(lar_part.Vx(l),lar_part.Vy(l),lar_part.Vz(l),lar_part.T(l));
	
	if(!loopInFV) {
	  
	  if(inFV) { loopInFV=true; start_FV=l; }
	  
	}else if(!inFV) {
	  lite_part.AddFiducialTrack(start_FV,l-1);
	  loopInFV=false;
	}
	}
      if(loopInFV){ lite_part.AddFiducialTrack(start_FV,lar_part.NumberTrajectoryPoints()-1); }

      lite_part.SetTrajectory(lite_track);
	
      lite_mct.Add(lite_part);
    }
    
    // Neutrino Information
    const simb::MCNeutrino lar_nu(mct_ptr->GetNeutrino());
    
    lite_mct.SetNeutrino( lar_nu.CCNC(),
			  lar_nu.Mode(),
			  lar_nu.InteractionType(),
			  lar_nu.Target(),
			  lar_nu.HitNuc(),
			  lar_nu.HitQuark(),
			  lar_nu.W(),
			  lar_nu.X(),
			  lar_nu.Y(),
			  lar_nu.QSqr() );
    
    // Save
    lite_data->push_back(lite_mct);
  }
}

//-------------------------------------------------------------------------------------------------
// MCParticle
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCParticle(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCParticle)][name_index];
  auto lite_data = (::larlite::event_mcpart*)(_mgr.get_data(::larlite::data::kMCParticle,mod_name));
  art::Handle<std::vector<simb::MCParticle> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kMCParticle)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {
    
    art::Ptr<simb::MCParticle> mcparticle_ptr(dh,i);
      
    larlite::mcpart mcpart_lite(mcparticle_ptr->TrackId(),
				mcparticle_ptr->PdgCode(),
				mcparticle_ptr->Process(), 
				mcparticle_ptr->Mother(),
				mcparticle_ptr->Mass(),
				mcparticle_ptr->StatusCode());

    mcpart_lite.SetPolarization(mcparticle_ptr->Polarization());
    mcpart_lite.SetRescatter(mcparticle_ptr->Rescatter());
    mcpart_lite.SetWeight(mcparticle_ptr->Weight());
      
    for(size_t k=0; k<(size_t)(mcparticle_ptr->NumberDaughters()); ++k)
      mcpart_lite.AddDaughter(mcparticle_ptr->Daughter(k));

    // Add trajectory points
    larlite::mctrajectory lite_track;
    lite_track.reserve(mcparticle_ptr->NumberTrajectoryPoints());
    
    bool   loopInFV=false;
    size_t start_FV=0;
    for(size_t l=0; l<(size_t)mcparticle_ptr->NumberTrajectoryPoints(); ++l) {
	
      lite_track.push_back(mcparticle_ptr->Position(l),
			   mcparticle_ptr->Momentum(l));
	
      // Record fiducial volume tracking
      bool inFV = false;//IsFV(mcparticle_ptr->Vx(l), mcparticle_ptr->Vy(l),mcparticle_ptr->Vz(l),mcparticle_ptr->T(l));
	
      if(!loopInFV) {
	
	if(inFV) { loopInFV=true; start_FV=l; }
	  
      }else if(!inFV) {
	mcpart_lite.AddFiducialTrack(start_FV,l-1);
	loopInFV=false;
      }
    }
    if(loopInFV){ mcpart_lite.AddFiducialTrack(start_FV,mcparticle_ptr->NumberTrajectoryPoints()-1); }
    
    mcpart_lite.SetTrajectory(lite_track);

    // Store address map for downstream association
    // ????????????????
    
    lite_data->push_back(mcpart_lite);
  }


}

//-------------------------------------------------------------------------------------------------
// MCShower
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCShower(const art::Event& evt, const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCShower)][name_index];
  auto lite_data = (::larlite::event_mcshower*)(_mgr.get_data(::larlite::data::kMCShower,mod_name));
  art::Handle<std::vector<sim::MCShower> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kMCShower)][mod_name] = true;
  for(auto const& mcs : *dh) {
    
    larlite::mcshower lite_mcs;
    lite_mcs.SetMotherID(mcs.MotherPDGID(), mcs.MotherTrackID());
    
    //lite_mcs.SetMotherAngles(mcs.phiMother, mcs.thetaMother);
    //mcs.uAngleMother, mcs.vAngleMother, mcs.wAngleMother);
    
    lite_mcs.SetMotherPoint(mcs.MotherPosition());
    
    lite_mcs.SetMotherProcess(mcs.MotherCreationProcess());
    
    lite_mcs.SetMotherMomentum(mcs.MotherMomentum());
    
    lite_mcs.SetDaughterTrackList(mcs.DaughterTrackID());
    
    //lite_mcs.SetDaughterAngles(mcs.phiDaughter, mcs.thetaDaughter);
    //mcs.uAngleDaughter, mcs.vAngleDaughter, mcs.wAngleDaughter);
    
    lite_mcs.SetDaughterMomentum(mcs.DaughterMomentum());
    lite_mcs.SetDaughterPosition(mcs.DaughterPosition());
    
    lite_mcs.SetPlaneCharge(mcs.Charge());
    
    //lite_mcs.SetEdepVtx(mcs.vtxEdep);
    
    lite_data->push_back(lite_mcs);
  }
  
}

DEFINE_ART_MODULE(LiteScanner)
