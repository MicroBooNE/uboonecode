////////////////////////////////////////////////////////////////////////
// Class:       LiteScanner
// Module Type: analyzer
// File:        LiteScanner_module.cc
//
// Generated at Wed Oct 15 18:41:39 2014 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

// ART includes
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArLite include
#include "DataFormat/storage_manager.h"

// LArSoft includes
#include "Geometry/Geometry.h"
#include "RawData/RawDigit.h"
#include "RecoBase/Wire.h"
#include "RecoBase/Hit.h"
#include "RecoBase/OpHit.h"
#include "RecoBase/OpFlash.h"
#include "RecoBase/Track.h"
#include "RecoBase/Cluster.h"
#include "RecoBase/SpacePoint.h"
#include "RecoBase/Shower.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/EndPoint2D.h"
#include "AnalysisBase/Calorimetry.h"
#include "AnalysisBase/CosmicTag.h"
#include "Simulation/SimChannel.h"
#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"
#include "OpticalDetectorData/FIFOChannel.h"
#include "OpticalDetectorData/OpticalTypes.h"
#include "MCBase/MCShower.h"
#include "Utilities/LArProperties.h"
#include "Utilities/GeometryUtilities.h"
#include "Utilities/DetectorProperties.h"

// std 
#include <vector>
#include <string>
#include <iostream>

class LiteScanner;

class LiteScanner : public art::EDAnalyzer {
public:
  explicit LiteScanner(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LiteScanner(LiteScanner const &) = delete;
  LiteScanner(LiteScanner &&) = delete;
  LiteScanner & operator = (LiteScanner const &) = delete;
  LiteScanner & operator = (LiteScanner &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();

private:
  
  // Utility function
  void event_init();

  //
  // Simple data product reader function
  //
  /// Function to read & store SimChannel data
  void ReadSimChannel(const art::Event& evt, const size_t name_index);
  /// Function to read & store reconstructed hit data
  void ReadHit(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed op-hit data
  void ReadOpHit(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed op-flash data
  void ReadOpFlash(const art::Event& evt,  const size_t name_index);
  /// Function to read & store calibrated wire data
  void ReadWire(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed cosmic-tag data
  void ReadCosmicTag(const art::Event& evt,  const size_t name_index);
  /// Function to read & store reconstructed hit data
  void ReadCluster(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MC truth shower object
  void ReadMCShower(const art::Event& evt, const size_t name_index);
  /// Function to read & store spacepoints
  void ReadSpacePoint(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Tracking information
  void ReadTrack(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MCTruth information
  void ReadMCTruth(const art::Event& evt,  const size_t name_index);
  /// Function to read & store MCParticle information
  void ReadMCParticle(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Shower variables
  void ReadShower(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Calorimetry variables
  void ReadCalorimetry(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Calorimetry variables
  void ReadVertex(const art::Event& evt,  const size_t name_index);
  /// Function to read & store Calorimetry variables
  void ReadEndPoint2D(const art::Event& evt,  const size_t name_index);

  //
  // Association reader function
  //
  /// Cluster => X association
  void ReadClusterAssociation(const art::Event& evt,  const size_t name_index);
  /// SpacePoint => X association
  void ReadSpacePointAssociation(const art::Event& evt,  const size_t name_index);
  /// Track => X association
  void ReadTrackAssociation(const art::Event& evt,  const size_t name_index);
  /// CosmicTag => X association
  void ReadCosmicTagAssociation(const art::Event& evt,  const size_t name_index);
  /// Shower => X association
  void ReadShowerAssociation(const art::Event& evt,  const size_t name_index);
  /// Calorimetry => X association
  void ReadCalorimetryAssociation(const art::Event& evt,  const size_t name_index);
  /// Vertex => X association
  void ReadVertexAssociation(const art::Event& evt,  const size_t name_index);
  /// EP2D => X association
  void ReadEndPoint2DAssociation(const art::Event& evt,  const size_t name_index);

  // Declare member data here.
  ::larlite::storage_manager _mgr;
  // Module label holder
  std::vector<std::vector<std::string> > fModuleLabel_v;
  // Boolean holder to tell us whether specific producer's data is read or not
  std::vector<std::map<std::string,bool> > fDataReadFlag_v;
  // art::Ptr local storage. Value = index of data product & index of label
  std::map<art::Ptr<recob::Hit>,        std::pair<size_t,size_t> > fPtrIndex_hit;
  std::map<art::Ptr<recob::Cluster>,    std::pair<size_t,size_t> > fPtrIndex_cluster;
  std::map<art::Ptr<recob::Shower>,     std::pair<size_t,size_t> > fPtrIndex_shower;
  std::map<art::Ptr<recob::Vertex>,     std::pair<size_t,size_t> > fPtrIndex_vertex;
  std::map<art::Ptr<recob::Track>,      std::pair<size_t,size_t> > fPtrIndex_track;
  std::map<art::Ptr<anab::CosmicTag>,  std::pair<size_t,size_t> > fPtrIndex_cosmictag;
  std::map<art::Ptr<anab::Calorimetry>, std::pair<size_t,size_t> > fPtrIndex_calo;
  std::map<art::Ptr<recob::SpacePoint>, std::pair<size_t,size_t> > fPtrIndex_sps;
  std::map<art::Ptr<recob::EndPoint2D>, std::pair<size_t,size_t> > fPtrIndex_end2d;

};


LiteScanner::LiteScanner(fhicl::ParameterSet const & p) 
  : EDAnalyzer(p)
  , fModuleLabel_v  ((size_t)(::larlite::data::kDATA_TYPE_MAX),std::vector<std::string>())
  , fDataReadFlag_v ((size_t)(::larlite::data::kDATA_TYPE_MAX),std::map<std::string,bool>())
  
 // More initializers here.
{
  //  fDataReadFlag.resize((size_t)(::larlite::data::kDATA_TYPE_MAX),std::map<std::string,
		       
  for(size_t i = 0; i<(size_t)(::larlite::data::kDATA_TYPE_MAX); ++i) {

    std::vector<std::string> labels;
    switch((::larlite::data::DataType_t)i) {
    case ::larlite::data::kUndefined:
    case ::larlite::data::kEvent:
      fModuleLabel_v[i] = labels;
      break;
    default:
      labels = p.get<std::vector<std::string> >(::larlite::data::kDATA_TREE_NAME[i].c_str(),labels);
      fModuleLabel_v[i] = labels;
      for(auto const& label : labels)
	fDataReadFlag_v[i].insert(std::make_pair(label,false));
    }
  }  
}

void LiteScanner::beginJob() {
  //_mgr.set_verbosity(larlite::msg::kDEBUG);
  _mgr.set_out_filename("larlite.root");
  _mgr.set_io_mode(::larlite::storage_manager::kWRITE);
  _mgr.open();
}

void LiteScanner::endJob() {
  _mgr.close();
}

void LiteScanner::event_init()
{
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    for(auto& name_bool : fDataReadFlag_v[i])

      name_bool.second = false;

  }
  fPtrIndex_hit.clear();
  fPtrIndex_cluster.clear();
  fPtrIndex_shower.clear();
  fPtrIndex_vertex.clear();
  fPtrIndex_cosmictag.clear();
  fPtrIndex_track.clear();
  fPtrIndex_calo.clear();
  fPtrIndex_sps.clear();
  fPtrIndex_end2d.clear();
}

void LiteScanner::analyze(art::Event const & e)
{

  event_init();

  //
  // Loop over data type to store data & locally art::Ptr
  //
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    auto label_v = fModuleLabel_v[i];
    ::larlite::data::DataType_t lite_type = (::larlite::data::DataType_t)i;

    for(size_t j=0; j<label_v.size(); ++j) {

      switch(lite_type) {
      case ::larlite::data::kSimChannel:
	ReadSimChannel(e,j); break;
      case ::larlite::data::kMCShower:
	ReadMCShower(e,j); break;
      case ::larlite::data::kWire:
	ReadWire(e,j); break;
      case ::larlite::data::kHit:
	ReadHit(e,j); break;
      case ::larlite::data::kOpHit:
	ReadOpHit(e,j); break;
      case ::larlite::data::kOpFlash:
	ReadOpFlash(e,j); break;
      case ::larlite::data::kCluster:
	ReadCluster(e,j); break;
      case ::larlite::data::kCosmicTag:
	ReadCosmicTag(e,j); break;
      case ::larlite::data::kEndPoint2D:
	ReadEndPoint2D(e,j); break;
      case ::larlite::data::kSpacePoint:
	ReadSpacePoint(e,j); break;
      case ::larlite::data::kTrack:
	ReadTrack(e,j); break;
      case ::larlite::data::kShower:
	ReadShower(e,j); break;
      case ::larlite::data::kVertex:
	ReadVertex(e,j); break;
      case ::larlite::data::kMCTruth:
	ReadMCTruth(e,j); break;
      case ::larlite::data::kMCParticle:
	ReadMCParticle(e,j); break;
      case ::larlite::data::kCalorimetry:
	ReadCalorimetry(e,j); break;
      case ::larlite::data::kUndefined:
      case ::larlite::data::kEvent:
      default:
	continue;
      }
      auto lite_data = _mgr.get_data(lite_type,label_v[j]);
      lite_data->set_run      ( e.id().run()    );
      lite_data->set_subrun   ( e.id().subRun() );
      lite_data->set_event_id ( e.id().event()  );
    }
  }

  //
  // Loop over data type to store association
  //
  for(size_t i=0; i<fModuleLabel_v.size(); ++i) {

    auto label_v = fModuleLabel_v[i];
    ::larlite::data::DataType_t lite_type = (::larlite::data::DataType_t)i;

    for(size_t j=0; j<label_v.size(); ++j) {

      switch(lite_type) {
      case ::larlite::data::kCluster:
	ReadClusterAssociation(e,j); break;
      case ::larlite::data::kCosmicTag:
	ReadCosmicTagAssociation(e,j); break;
      case ::larlite::data::kEndPoint2D:
	ReadEndPoint2DAssociation(e,j); break;
      case ::larlite::data::kSpacePoint:
	ReadSpacePointAssociation(e,j); break;
      case ::larlite::data::kTrack:
	ReadTrackAssociation(e,j); break;
      case ::larlite::data::kShower:
	ReadShowerAssociation(e,j); break;
      case ::larlite::data::kVertex:
	ReadVertexAssociation(e,j); break;
      case ::larlite::data::kCalorimetry:
	ReadCalorimetryAssociation(e,j); break;
	// Currently associations FROM the followings are not supported
      case ::larlite::data::kMCTruth:
      case ::larlite::data::kMCParticle:
      case ::larlite::data::kOpHit:
      case ::larlite::data::kOpFlash:
      case ::larlite::data::kSimChannel:
      case ::larlite::data::kMCShower:
      case ::larlite::data::kWire:
      case ::larlite::data::kHit:
      case ::larlite::data::kUndefined:
      case ::larlite::data::kEvent:
      default:
	continue;
      }
    }
  }
  _mgr.next_event();
}

//-------------------------------------------------------------------------------------------------
// SimChannel
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadSimChannel(const art::Event& evt, const size_t name_index)
{ 
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSimChannel)][name_index];
  auto lite_data = (::larlite::event_simch*)(_mgr.get_data(::larlite::data::kSimChannel,mod_name));
  art::Handle<std::vector<sim::SimChannel> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Wire
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadWire(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kWire)][name_index];
  auto lite_data = (::larlite::event_wire*)(_mgr.get_data(::larlite::data::kWire,mod_name));
  art::Handle<std::vector<recob::Wire> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Hit
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadHit(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kHit)][name_index];
  auto lite_data = (::larlite::event_hit*)(_mgr.get_data(::larlite::data::kHit,mod_name));
  art::Handle<std::vector<recob::Hit> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kHit)][mod_name] = true;
  for(size_t i=0; i<dh->size(); i++){
      
    art::Ptr<recob::Hit> hit_ptr(dh,i);
    
    larlite::hit lite_hit;
    
    lite_hit.set_waveform(hit_ptr->fHitSignal);
    lite_hit.set_times(hit_ptr->StartTime(),
			hit_ptr->PeakTime(),
			hit_ptr->EndTime());
    lite_hit.set_times_err(hit_ptr->SigmaStartTime(),
			    hit_ptr->SigmaPeakTime(),
			    hit_ptr->SigmaEndTime());
    lite_hit.set_charge(hit_ptr->Charge(),hit_ptr->Charge(true));
    lite_hit.set_charge_err(hit_ptr->SigmaCharge(),hit_ptr->SigmaCharge(true));
    lite_hit.set_multiplicity(hit_ptr->Multiplicity());
    lite_hit.set_channel(hit_ptr->Channel());
    lite_hit.set_wire(hit_ptr->WireID().Wire);
    lite_hit.set_fit_goodness(hit_ptr->GoodnessOfFit());
    lite_hit.set_view((larlite::geo::View_t)(hit_ptr->View()));
    lite_hit.set_sigtype((larlite::geo::SigType_t)(hit_ptr->SignalType()));
    
    // Store address map for downstream association
    fPtrIndex_hit[hit_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_hit);
    
  }
}

//-------------------------------------------------------------------------------------------------
// Cluster
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCluster(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCluster)][name_index];
  auto lite_data = (::larlite::event_cluster*)(_mgr.get_data(::larlite::data::kCluster,mod_name));
  art::Handle<std::vector<recob::Cluster> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kCluster)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {
    
    art::Ptr<recob::Cluster> cluster_ptr(dh,i);
      
    larlite::cluster lite_cluster;
    lite_cluster.set_charge(cluster_ptr->Charge());
    lite_cluster.set_dtdw(cluster_ptr->dTdW());
    lite_cluster.set_dqdw(cluster_ptr->dQdW());
    lite_cluster.set_dtdw_err(cluster_ptr->SigmadTdW());
    lite_cluster.set_dqdw_err(cluster_ptr->SigmadQdW());
    lite_cluster.set_id(cluster_ptr->ID());
    lite_cluster.set_view((larlite::geo::View_t)(cluster_ptr->View()));
    lite_cluster.set_start_vtx(cluster_ptr->StartPos());
    lite_cluster.set_end_vtx(cluster_ptr->EndPos());
    lite_cluster.set_start_vtx_err(cluster_ptr->SigmaStartPos());
    lite_cluster.set_end_vtx_err(cluster_ptr->SigmaEndPos());
    
    // Store address map for downstream association
    fPtrIndex_cluster[cluster_ptr] = std::make_pair(lite_data->size(),name_index);
    
    lite_data->push_back(lite_cluster);
  }
}

void LiteScanner::ReadClusterAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCluster)][name_index];
  art::Handle<std::vector<recob::Cluster> > dh;
  evt.getByLabel(mod_name,dh);
  if(!dh.isValid()) return;

  //
  // Cluster=>Hit association
  //
  // Only store if any hit is stored
  std::vector<larlite::AssSet_t> ass_set_v(fModuleLabel_v[(size_t)(::larlite::data::kHit)].size());
  if(ass_set_v.size()) {

    auto lite_data = _mgr.get_data(::larlite::data::kCluster,mod_name);
    art::FindManyP<recob::Hit> hit_m(dh, evt, mod_name);

    for(size_t i=0; i<dh->size(); ++i) {

      const std::vector<art::Ptr<recob::Hit> > hit_ptr_v = hit_m.at(i);

      std::vector<larlite::AssUnit_t> ass_unit_v(ass_set_v.size());

      for(auto& hit_ptr : hit_ptr_v) {

	auto info_iter = fPtrIndex_hit.find(hit_ptr);

	if(info_iter == fPtrIndex_hit.end()) continue;

	auto data_index = (*info_iter).second.first;
	auto name_index = (*info_iter).second.second;

	ass_unit_v.at(name_index).push_back(data_index);
      }
      for(size_t i=0; i<ass_set_v.size(); ++i)

	ass_set_v[i].push_back(ass_unit_v[i]);

    } // end looping over clusters
	
    // Store associations to hits if there's any found
    for(size_t i=0; i<ass_set_v.size(); ++i) {

      // Loop over in one association set, store if there's any
      for(auto const& ass_unit : ass_set_v[i]) {

	if(ass_unit.size()) {

	  auto ass_name = fModuleLabel_v[(size_t)(::larlite::data::kHit)][i];

	  larlite::ProductID_t type = std::make_pair(::larlite::data::kHit,ass_name);

	  lite_data->set_association(type,ass_set_v[i]);

	  break;
	}
      }// end looping over association set
    }// end looping over a vector of association set
  }// end storing Cluster=>Hit association
}

//-------------------------------------------------------------------------------------------------
// OpHit
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadOpHit(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kOpHit)][name_index];
  auto lite_data = (::larlite::event_ophit*)(_mgr.get_data(::larlite::data::kOpHit,mod_name));
  art::Handle<std::vector<recob::OpHit> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  fDataReadFlag_v[(size_t)(::larlite::data::kOpHit)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<recob::OpHit> hit_ptr(dh,i);

    ::larlite::ophit lite_hit( hit_ptr->OpChannel(),
			       hit_ptr->PeakTime(),
			       hit_ptr->PeakTimeAbs(),
			       hit_ptr->PeakTime(),
			       hit_ptr->Frame(),
			       hit_ptr->Width(),
			       hit_ptr->Area(),
			       hit_ptr->Amplitude(),
			       hit_ptr->PE(),
			       hit_ptr->FastToTotal() );
    
    lite_data->push_back(lite_hit);
  }
}

//-------------------------------------------------------------------------------------------------
// OpFlash
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadOpFlash(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kOpFlash)][name_index];
  auto lite_data = (::larlite::event_opflash*)(_mgr.get_data(::larlite::data::kOpFlash,mod_name));
  art::Handle<std::vector<recob::OpFlash> > dh;
  evt.getByLabel(mod_name,dh);

  if(!dh.isValid()) return;

  art::ServiceHandle<geo::Geometry> geo;
  fDataReadFlag_v[(size_t)(::larlite::data::kOpFlash)][mod_name] = true;
  for(size_t i=0; i<dh->size(); ++i) {

    art::Ptr<recob::OpFlash> flash_ptr(dh,i);

    std::vector<double> pe_per_opdet;
    pe_per_opdet.reserve(geo->NOpChannels());
    for(size_t j=0; j<geo->NOpChannels(); ++j)
      pe_per_opdet.push_back(flash_ptr->PE(j));

    ::larlite::OpFlash lite_flash( flash_ptr->Time(),
				   flash_ptr->TimeWidth(),
				   flash_ptr->AbsTime(),
				   flash_ptr->Frame(),
				   pe_per_opdet,
				   flash_ptr->InBeamFrame(),
				   flash_ptr->OnBeamTime(),
				   flash_ptr->FastToTotal(),
				   flash_ptr->YCenter(),
				   flash_ptr->YWidth(),
				   flash_ptr->ZCenter(),
				   flash_ptr->ZWidth(),
				   flash_ptr->WireCenters(),
				   flash_ptr->WireWidth());
    
    lite_data->push_back(lite_flash);
  }

}

//-------------------------------------------------------------------------------------------------
// CosmicTag
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCosmicTag(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCosmicTag)][name_index];
  auto lite_data = (::larlite::event_cosmictag*)(_mgr.get_data(::larlite::data::kCosmicTag,mod_name));
  art::Handle<std::vector<anab::CosmicTag> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadCosmicTagAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCosmicTag)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kCosmicTag,mod_name));
  art::Handle<std::vector<anab::CosmicTag> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// SpacePoint
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadSpacePoint(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSpacePoint)][name_index];
  auto lite_data = (::larlite::event_spacepoint*)(_mgr.get_data(::larlite::data::kSpacePoint,mod_name));
  art::Handle<std::vector<recob::SpacePoint> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadSpacePointAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kSpacePoint)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kSpacePoint,mod_name));
  art::Handle<std::vector<recob::SpacePoint> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Track
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadTrack(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kTrack)][name_index];
  auto lite_data = (::larlite::event_track*)(_mgr.get_data(::larlite::data::kTrack,mod_name));
  art::Handle<std::vector<recob::Track> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadTrackAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kTrack)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kTrack,mod_name));
  art::Handle<std::vector<recob::Track> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Shower
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadShower(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kShower)][name_index];
  auto lite_data = (::larlite::event_shower*)(_mgr.get_data(::larlite::data::kShower,mod_name));
  art::Handle<std::vector<recob::Shower> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadShowerAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kShower)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kShower,mod_name));
  art::Handle<std::vector<recob::Shower> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// EndPoint2D
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadEndPoint2D(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kEndPoint2D)][name_index];
  auto lite_data = (::larlite::event_endpoint2d*)(_mgr.get_data(::larlite::data::kEndPoint2D,mod_name));
  art::Handle<std::vector<recob::EndPoint2D> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadEndPoint2DAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kEndPoint2D)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kEndPoint2D,mod_name));
  art::Handle<std::vector<recob::EndPoint2D> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Vertex
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadVertex(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kVertex)][name_index];
  auto lite_data = (::larlite::event_vertex*)(_mgr.get_data(::larlite::data::kVertex,mod_name));
  art::Handle<std::vector<recob::Vertex> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadVertexAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kVertex)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kVertex,mod_name));
  art::Handle<std::vector<recob::Vertex> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// Calorimetry
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadCalorimetry(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCalorimetry)][name_index];
  auto lite_data = (::larlite::event_calorimetry*)(_mgr.get_data(::larlite::data::kCalorimetry,mod_name));
  art::Handle<std::vector<anab::Calorimetry> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

void LiteScanner::ReadCalorimetryAssociation(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kCalorimetry)][name_index];
  auto lite_data = (::larlite::event_base*)(_mgr.get_data(::larlite::data::kCalorimetry,mod_name));
  art::Handle<std::vector<anab::Calorimetry> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// MCTruth
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCTruth(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCTruth)][name_index];
  auto lite_data = (::larlite::event_mctruth*)(_mgr.get_data(::larlite::data::kMCTruth,mod_name));
  art::Handle<std::vector<simb::MCTruth> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// MCParticle
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCParticle(const art::Event& evt,  const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCParticle)][name_index];
  auto lite_data = (::larlite::event_mcpart*)(_mgr.get_data(::larlite::data::kMCParticle,mod_name));
  art::Handle<std::vector<simb::MCParticle> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

//-------------------------------------------------------------------------------------------------
// MCShower
//-------------------------------------------------------------------------------------------------
void LiteScanner::ReadMCShower(const art::Event& evt, const size_t name_index)
{
  auto mod_name = fModuleLabel_v[(size_t)(::larlite::data::kMCShower)][name_index];
  auto lite_data = (::larlite::event_mcshower*)(_mgr.get_data(::larlite::data::kMCShower,mod_name));
  art::Handle<std::vector<sim::MCShower> > dh;
  evt.getByLabel(mod_name,dh);
  std::cout<<lite_data<<std::endl;
  if(!dh.isValid()) return;
}

DEFINE_ART_MODULE(LiteScanner)
