BEGIN_PROLOG

microboone_signalshapingservice:
{

  NConfigs:  1  # if set to 1, you get the same config for all channels
                # otherwise, you need to supply the map of channel <-> config... see GetConfig()

  ADCPerPCAtLowestASICGain: 9390 #ADC/pC
  # ASICGains:           [4.7, 7.8, 14, 25] #Default: 7.8
  #mV/fC for different configs and U, V & Y planes
  ASICGainInMVPerFC: [ [14.0, 14.0, 14.0], [4.7, 14.0, 14.0] ]  

  #Vector of peaking time (microseconds) for differet configs and U, V & Y planes
  ShapeTimeConst:  [ [2.0, 2.0, 2.0], [ 1.0, 2.0, 2.0] ] 
  
  #Noise Factor - rms ADCs @ lowest ASIC Gain (4.7 mV/fC)
  #Entries listed per shaping time, in increasing order(for 0.5, 1.0, 2.0, 3.0 us)
  # to turn off the noise, set GenNoise: 0 in DetSim/detsimmodules.fcl

  NoiseFactVec:    [ [ 1.12, 0.86, 0.60, 0.55 ], [ 1.12, 0.86, 0.60, 0.55 ], [ 0.89, 0.66, 0.48, 0.43 ] ]

  NViews:                  3
  ViewIndex:             [0, 1, 2]  # gives the larsoft plane number corresponding to each local plane number
  ViewForNormalization:   2         # lets say this is the local plane number, may need to rethink


  FieldRespAmpVec:  [1.0, 1.0, 1.0]

  # there is commented code in SignalShapingService to test vector of vector of vectors... works!
  #TestParams:       [[[1.0, 2.0],[3.0, 4.0]], [[5.0,6.0],[7.0, 8.0]]]


#-------------------------------------------------------------
# Switching between Calibrated and Old field response

#UseCalibratedResponses: true
#FieldResponseFNameBase: "uboone_response_70kV"
#CalibResponseTOffset: [-21.61, -21.61, -21.61]   # in us time offset to align all three planes
			
UseCalibratedResponses: false
FieldResponseFNameBase: "uboone_response"
CalibResponseTOffset: [0, 0, 0]   # in us time offset to align all three planes


#---------------------------------------------------------------
# Settings for old-style responses (no dynamic induced charge)

  NResponses:           [ [1, 1, 1], [1, 1, 1] ]  # number of responses per view, including primary. 1 is current number
  NYZResponses:         [ [1, 2, 1], [1, 2, 1] ]  # number of responses per view for YZ-depenedent field responses
  NdatadrivenResponses: [ [3, 3, 2], [3, 3, 2] ]  # number of responses per view for data driven field responses
  NActiveResponses:     [ [1, 1, 1], [1, 1, 1] ]  # number of active responses per view, including primary. 1 is current number
  NYZActiveResponses:   [ [1, 2, 1], [1, 2, 1] ]  # number of active responses per view for YZ-dependent field responses
  NdatadrivenActiveResponses: [ [3, 3, 2], [3, 3, 2] ]  # number of active responses per view for data driven field responses
  FieldResponseFVersion:  [ "v3.1", "v3.1" ] #[ "v0.1", "v0.1" ]	 
  
  DefaultEField:       0.5
  DefaultTemperature:  87.0

  TimeScaleParams:   [ 1.0, 0.806 ] # this does the scaling from full- to half-field
                                      # good to ~0.2% over the range of the velocity ratio for 1-0.4 in the field
                                      # and <2% between views (calibrated on the Y view)
                                      #  not used for calibrated responses

  StretchFullResponse:  false         # to maintain the original stretching scheme
                                      # false means only the field response is stretched, not the electronic response
  YZdependentResponse:  true          # flag to use YZ-dependent field responses
  datadrivenResponse:   true          # flag to use data driven field response (also by default uses specific electronics response for misconfigured U channels on FT 1)
  YZchargeScaling:      [ [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0] ] # scale charge; from transparency effects - ramification of shorted wires
  #YZwireOverlap:        [ [ [296, 671], [2400, 3071], [4800, 6143] ], [ [1168, 1903], [3568, 4303], [7136, 7263] ] ] # channel ranges for shorted wires and corresponding channel ranges for wires effected on other planes

  IncludeMisconfiguredU: true
  MisconfiguredU:	[ [2016, 2095], [2192, 2303], [2352, 2382] ]	# channel range of misconfigured U-plane wires during run 1

  DeconNorm: 200.

# Settings for synthesized response, including adjacent wires

  #NResponses:            [ [5, 5, 5], [5, 5, 5] ]  # number of responses per view, including primary.
  #NActiveResponses:     [ [5, 3, 4], [5, 3, 4] ]  # number of active responses per view, including primary.
  #NActiveResponses:      [ [5, 5, 5], [5, 5, 5] ]  # number of active responses per view, including primary.
  #FieldResponseFVersion: [ "v2.1", "v2.1" ]

#----------------------------------------------------------------

  DefaultDriftVelocity: [-1,-1,-1] # in cm/usec per drift region ... if negative value, use LArSoft derived drift velocity

  Drift3DCorrVec: [ 1.0, 1.0, 1.0 ]
  
  FieldResponseFNameBase: "uboone_response"
  FieldResponseHNameBase: "FieldResponse"

  DeconvPol:       [ -1, 1, 1 ] #Switch for RawDigit-RecobWire normalization. Entry 0,1,2 are U,V,Y respectively
                                #-1 means normalizes to min ADC count, +1 to max

  # For the filters, frequency (x) is measured in
  # cycles/microsecond.  The conversion to frequency bin depends on FFT size
  # samping rate.

  # This is the original Wiener filter
  #FilterFuncVec:  [ "(x>0.0)? (gaus(0)*exp(-0.5*pow(x/[3],[4]))): 0.0", "(x>0.0)? (gaus(0)*exp(-0.5*pow(x/[3],[4]))): 0.0", "(x>0.0)? ([0]*exp(-0.5*(((x-[1])/[2])^2)^[4])) + 0*[3]: 0.0" ]
  #FilterParamsVec:   [ [ 1.803396, 1.69, 1.55, 0.19, 3.75 ], [ 1.849030, 1.46, 1.33, 0.23, 4.89 ], [ 1.034516, 0.08, 0.15, 0.0, 2.17 ] ]
  #FilterWidthCorrectionFactor:  [ 1.0, 1.0, 1.0 ]

  # This is Mike Mooney's new gaussian filter
  # Introduced on July 29, 2016
  FilterFuncVec:                [ "(x>0.0)*gaus", "(x>0.0)*gaus", "(x>0.0)*gaus" ]
  FilterParamsVec:              [ [ 1.0, 0.0, 0.1 ], [ 1.0, 0.0, 0.1 ], [ 1.0, 0.0, 0.1 ] ]
  FilterWidthCorrectionFactor:  [ 0.738, 0.738, 0.738 ]

  # never omit mentioning a parameter in a formula; in collection plane, 4th parameter is unused but it must still appear in the expression
  FilterFuncVecICTime:  [ "(x<=0.0)? 0.0: (gaus(0)+[5]*(x+0.005)+[6]*pow((x+0.005),[7]))*exp(-0.5*pow((x+0.005)/[3],[4]))",
                          "(x<=0.0)? 0.0: (gaus(0)+[5]*(x+0.005)+[6]*pow((x+0.005),[7]))*exp(-0.5*pow((x+0.005)/[3],[4]))",
                          "(x<=0.0)? 0.0: [0]*exp(-0.5*((((x+0.005)-[1])/[2])^2)^[4]) + 0*[3]" ]

  FilterParamsVecICTime:  [ [ 33.8,  3.62, 9.66, 0.220, 4.17, 21.9, -0.401, -0.784 ],
                            [ 99.6, -12.2, 16.1, 0.267, 5.63, -57.8, -15.1, -0.295 ], 
                            [ 39.8, 0.0837, 0.161, 0.4, 1.72 ] ]
  FilterScaleVecICTime:  [ 1.0, 1.0, 1.0 ]
  FilterFuncVecICWire:  [ "(gaus(0)+[5]*x+[6]*pow(x,[7]))*exp(-0.5*pow(x/[3],[4]))", "(gaus(0)+[5]*x+[6]*pow(x,[7]))*exp(-0.5*pow(x/[3],[4]))", "(1.0-gaus(0))*[3]" ]
  FilterParamsVecICWire:  [ [ 104.5, -2.23, 5.75, 0.205, 1.80, 287.3, -0.411, 0.0641 ], [ 196.1, -0.939, 4.14, 0.269, 4.98, -79.2, 2.42, 1.25 ], [ 0.0897, 0.154, -0.0578, 105.6 ] ]
  FilterScaleVecICWire:  [ 2.0, 1.5, 1.0 ]
  FilterNormVecIC:  [ 3362.73, 7447.34, 4202.88 ]

  GetFilterFromHisto:   false  

  FilterFunctionFname:  "uboone_filters_v0.1.root"
  FilterHistoName:	"noisefilter_%d"       

  PrintResponses: false  

}

# Dynamic induced charge field response.

microboone_dic_signalshapingservice: @local::microboone_signalshapingservice
microboone_dic_signalshapingservice.NResponses:       [ [5, 5, 5], [5, 5, 5] ]  # number of responses per view, including primary.
#microboone_dic_signalshapingservice.NActiveResponses: [ [5, 3, 4], [5, 3, 4] ]  # number of active responses per view, including primary.
microboone_dic_signalshapingservice.NActiveResponses: [ [5, 5, 5], [5, 5, 5] ]  # number of active responses per view, including primary.
microboone_dic_signalshapingservice.CalibResponseTOffset: [0.0, 0.0, 0.0] # in us time offset to align all three planes
microboone_dic_signalshapingservice.FieldResponseFVersion: [ "v2.1", "v2.1" ]
microboone_dic_signalshapingservice.DeconNorm:  200.

END_PROLOG
