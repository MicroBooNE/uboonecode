////////////////////////////////////////////////////////////////////////
// Class:       TestDBI
// Module Type: analyzer
// File:        TestDBI_module.cc
//
// Generated at Wed Feb 11 07:17:16 2015 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_08_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "larcore/Geometry/Geometry.h"

#include "larevt/CalibrationDBI/Interface/DetPedestalService.h"
#include "larevt/CalibrationDBI/Interface/DetPedestalProvider.h"

#include "larevt/CalibrationDBI/Interface/ChannelStatusService.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusProvider.h"

#include "larevt/CalibrationDBI/Interface/PmtGainService.h"
#include "larevt/CalibrationDBI/Interface/PmtGainProvider.h"

#include "larevt/CalibrationDBI/Interface/ElectronicsCalibService.h"
#include "larevt/CalibrationDBI/Interface/ElectronicsCalibProvider.h"

#include "larevt/CalibrationDBI/IOVData/CalibrationExtraInfo.h"
#include "larevt/CalibrationDBI/IOVData/IOVDataError.h"

//#include "UbooneElectronLifetimeService.h"
//#include "UbooneElectronLifetimeProvider.h"



// ROOT
#include "TH1D.h"
#include "TCanvas.h"

class TestDBI : public art::EDAnalyzer {
public:
  explicit TestDBI(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TestDBI(TestDBI const &) = delete;
  TestDBI(TestDBI &&) = delete;
  TestDBI & operator = (TestDBI const &) = delete;
  TestDBI & operator = (TestDBI &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  TH1D* fHist_Col;
  TH1D* fHist_Ind;
  
  std::string fRDModuleLabel;
};


TestDBI::TestDBI(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
  fHist_Col(new TH1D("Collection","Collection",400, 350.0,550.0)),
  fHist_Ind(new TH1D("Induction" ,"Induction" ,400,2000.0,2200.0)),
  fRDModuleLabel(p.get<std::string>("RDModuleLabel"))
{}


void TestDBI::analyze(art::Event const & evt)
{

  art::ServiceHandle<geo::Geometry> geo;
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  
  evt.getByLabel(fRDModuleLabel, digitVecHandle);
  for (auto iter = digitVecHandle->begin(); iter != digitVecHandle->end(); ++iter) {
    raw::RawDigit digit = *iter;
    unsigned int ch = digit.Channel();
    geo::SigType_t sigtype = geo->SignalType(ch);
    std::vector<short> rawadc(digit.Samples());
    raw::Uncompress(digit.ADCs(), rawadc, digit.Compression());
    
    double sum = 0;
    for (auto itADC = rawadc.begin(); itADC != rawadc.end(); ++itADC) {
      sum += *itADC;
    }
    
    sum /= digit.Samples();
    if (sigtype == geo::kCollection) {
      fHist_Col->Fill(sum);
    }
    else if (sigtype == geo::kInduction) {
      fHist_Ind->Fill(sum);
    }
  }//end loop over digits

  std::cout<<"Calibration info at time: "<<evt.time().value()<<std::endl;

  const lariov::DetPedestalProvider& pedestalRetrievalAlg = art::ServiceHandle<lariov::DetPedestalService>()->GetPedestalProvider();
  std::cout<<"PEDESTAL "<<pedestalRetrievalAlg.PedMean(8100)<<std::endl;   


  // Plot 
  TCanvas c("c","",600,500);
  fHist_Col->Draw();
  c.SaveAs("CollHist.png");
  fHist_Ind->Draw();
  c.SaveAs("IndHist.png");
  
  const lariov::ChannelStatusProvider& status_provider = art::ServiceHandle<lariov::ChannelStatusService>()->GetProvider();
  std::cout<<"  Channel 25 Status: "<<status_provider.Status(25)<<std::endl;
  
  //const lariov::UbooneElectronLifetimeProvider& elifetime_provider = art::ServiceHandle<lariov::UbooneElectronLifetimeService>()->GetProvider();
  //std::cout<<"LIFETIME: "<<elifetime_provider.ExpOffset()<<" "<<elifetime_provider.TimeConstantErr()<<std::endl;
  
  const lariov::PmtGainProvider& gain_provider = art::ServiceHandle<lariov::PmtGainService>()->GetProvider();
  for (unsigned int i=0; i!= geo->NOpDets(); ++i) {
    if (geo->IsValidOpChannel(i) && i<32) {
      std::cout<<"Channel "<<i <<" GAIN: "<<gain_provider.Gain(i)<<" "<<gain_provider.GainErr(i) <<std::endl;
    }
    else if (geo->IsValidOpChannel(i)) {
      std::cout<<"Channel "<<i<<std::endl;
    }
  }
  
  const lariov::ElectronicsCalibProvider& elec_provider = art::ServiceHandle<lariov::ElectronicsCalibService>()->GetProvider();
  raw::ChannelID_t elec_chan = 2019;
  std::cout<<"Electronics Calibration Test"<<std::endl;
  std::cout<<"  Channel: "<<elec_chan<<std::endl;
  std::cout<<"  Gain: "<<elec_provider.Gain(elec_chan)<<std::endl;
  std::cout<<"  GainErr: "<<elec_provider.GainErr(elec_chan)<<std::endl;
  std::cout<<"  ShapingTime: "<<elec_provider.ShapingTime(elec_chan)<<std::endl;
  std::cout<<"  ShapingTimeErr: "<<elec_provider.ShapingTimeErr(elec_chan)<<std::endl;
  std::cout<<"  IsMisconfig: "<<elec_provider.ExtraInfo(elec_chan).GetBoolData("is_misconfigured")<<std::endl;
  /*lariov::CalibrationExtraInfo extraInfo("test_info");
  extraInfo.AddOrReplaceIntData("dA",1);
  extraInfo.AddOrReplaceFloatData("dB",2.2);
  std::vector<int> dC; dC.push_back(3); dC.push_back(4);
  std::vector<float> dD; dD.push_back(5.5); dD.push_back(6.6);
  extraInfo.AddOrReplaceVecIntData("dC",dC);
  extraInfo.AddOrReplaceVecFloatData("dD",dD);
  extraInfo.AddOrReplaceStringData("dE","seven");
  
  std::cout<<"Extra data: "<<extraInfo.GetIntData("dA")<<" "
                           <<extraInfo.GetFloatData("dB")<<" "
			   <<extraInfo.GetVecIntData("dC")[0]<<" "
			   <<extraInfo.GetVecIntData("dC")[1]<<" "
			   <<extraInfo.GetVecFloatData("dD")[0]<<" "
			   <<extraInfo.GetVecFloatData("dD")[1]<<" "
			   <<extraInfo.GetStringData("dE")<<std::endl;
			   
  extraInfo.AddOrReplaceIntData("dA",7);
  extraInfo.AddOrReplaceFloatData("dB",6.6);
  dC.clear(); dC.push_back(5); dC.push_back(4);
  dD.clear(); dD.push_back(3.3); dD.push_back(2.2);
  extraInfo.AddOrReplaceVecIntData("dC",dC);
  extraInfo.AddOrReplaceVecFloatData("dD",dD);
  extraInfo.AddOrReplaceStringData("dE","one");	
  
  std::cout<<"Extra data2: "<<extraInfo.GetIntData("dA")<<" "
                           <<extraInfo.GetFloatData("dB")<<" "
			   <<extraInfo.GetVecIntData("dC")[0]<<" "
			   <<extraInfo.GetVecIntData("dC")[1]<<" "
			   <<extraInfo.GetVecFloatData("dD")[0]<<" "
			   <<extraInfo.GetVecFloatData("dD")[1]<<" "
			   <<extraInfo.GetStringData("dE")<<std::endl;		   
  
  extraInfo.ClearDataByLabel("dA");
  extraInfo.ClearDataByLabel("dB");
  extraInfo.ClearDataByLabel("dC");
  extraInfo.ClearDataByLabel("dD");
  extraInfo.ClearDataByLabel("dE");
  
  try {
    extraInfo.GetIntData("dA");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dA"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetFloatData("dB");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dB"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetVecIntData("dC");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dC"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetVecFloatData("dD");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dD"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetStringData("dE");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dE"<<e.what()<<std::endl;
  }
  
  extraInfo.AddOrReplaceIntData("dA",7);
  extraInfo.AddOrReplaceFloatData("dB",6.0);
  dC.clear(); dC.push_back(5); dC.push_back(4);
  dD.clear(); dD.push_back(3.0); dD.push_back(2.0);
  extraInfo.AddOrReplaceVecIntData("dC",dC);
  extraInfo.AddOrReplaceVecFloatData("dD",dD);
  extraInfo.AddOrReplaceStringData("dE","one");
  
  extraInfo.ClearAllData();
  
  try {
    extraInfo.GetIntData("dA");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dA"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetFloatData("dB");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dB"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetVecIntData("dC");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dC"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetVecFloatData("dD");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dD"<<e.what()<<std::endl;
  }
  
  try {
    extraInfo.GetStringData("dE");
  }
  catch (lariov::IOVDataError e) {
    std::cout <<"Exception dE"<<e.what()<<std::endl;
  }
  
  extraInfo.AddOrReplaceIntData("dA",7);
  extraInfo.AddOrReplaceFloatData("dA",6.0);
  extraInfo.ClearDataByLabel("dA");*/
}

DEFINE_ART_MODULE(TestDBI)
