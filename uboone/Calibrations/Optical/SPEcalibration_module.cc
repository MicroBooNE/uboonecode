////////////////////////////////////////////////////////////////////////
// Class:       analyzer
// Module Type: SPEcalibration
// File:        SPEcalibration_module.cc
//
// Generated at Tue Oct 13 13:14:22 2015 by Jarrett Moon using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

// ART libraries
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Optional/TFileService.h"

// Supporting libraries
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "LogicPulseFinder.h"

// C++ libraries
#include <iostream>
#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <algorithm>

// ROOT
#include "TDirectory.h"
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"

// LArSoft 
#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "uboone/TriggerSim/UBTriggerTypes.h"

//Optical Channel Maps
#include "uboone/Geometry/UBOpChannelTypes.h"
#include "uboone/Geometry/UBOpReadoutMap.h"

//RawDigits
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RawData/DAQHeader.h"
#include "lardataobj/RawData/TriggerData.h"

// Pulse finding
#include "uboone/OpticalDetectorAna/OpticalSubEvents/cfdiscriminator_algo/cfdiscriminator.hh"



class SPEcalibration;

class SPEcalibration : public art::EDAnalyzer {
public:
  explicit SPEcalibration(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SPEcalibration(SPEcalibration const &) = delete;
  SPEcalibration(SPEcalibration &&) = delete;
  SPEcalibration & operator = (SPEcalibration const &) = delete;
  SPEcalibration & operator = (SPEcalibration &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  int irun;
  int isubrun;
  int ievent;
  int opchannel;
  int readout_ch;
  double charge;
  double maxamp;
  double ave_baseline;
  double rms_baseline;
  double ave_baseline2;
  double rms_baseline2;
  double event_timestamp_sec;
  double event_timestamp_usec;
  double wfm_unixtime;
  double pulse_unixtime;
  unsigned int triggerbit;
  unsigned int trigs[10];
  int slot;
  int ch;

  std::vector<unsigned short> flasher_adcs;
  std::vector<unsigned short> adcs;
  std::vector<int>* event_nchfires;
  std::vector<double>* event_lastcosmicwin;
  std::vector<double>* event_lastsatcosmicwin;
  int nsamples = 0;
  double event_maxamp;

  unsigned short LOGIC_CH;
  unsigned short LOGIC_SLOT;
  unsigned short LOGIC_THRESHOLD;
  unsigned short SPE_SLOT;
  unsigned int WINDOW_MINSIZE;
  int COSMIC_THRESHOLD;
  unsigned short baseline_start;
  unsigned short baseline_end;
  unsigned short pulse_start;
  unsigned short pulse_end;
  unsigned short baseline2_start;
  unsigned short baseline2_end;
  double cfd_threshold;
  unsigned short cfd_delay;
  unsigned short cfd_deadtime;
  unsigned short cfd_width;
  bool SAVE_AVE_SPE;
  double AVESPE_RMSLIMIT;
  std::string OpDataModule;
  std::string DAQHeaderModule;
  bool fHandleOwnTFile;
  bool fAutoSlot;

  bool fOutputActive;
  TFile* fOutfile;
  TDirectory* fOutDir;
  TTree* fTouttree;
  TTree* fTpulsetree;
  TTree* fTevent;
  TH1D** hSPE_ave;
  TH1D** hSPE_norm;
  int hspe_nfills[32];

  // LED Pulser Mode
  void anayzeLEDPulserMode( const art::Event& evt );

  // Pulse Finding Mode
  void analyzePulseFindingMode( const art::Event& evt );

  // overriding these
  // virtual void beginRun(Run const&){}
  // virtual void endRun(Run const&){}
  virtual void beginSubRun(art::SubRun const&);
  virtual void endSubRun(art::SubRun const&);
  virtual void endJob();
 
  void SetupBranches();
  void SetupTFile( TFile* );
  void CloseoutTFile( TFile* );
  
  
};


SPEcalibration::SPEcalibration(fhicl::ParameterSet const& p)
  :EDAnalyzer(p)
{

  // Setup Analyzer
  LOGIC_CH         = p.get<unsigned short>( "LogicChannel", 39 );          // logic pulse channel for LED flasher
  LOGIC_SLOT       = p.get<unsigned short>( "LogicSlot", 6 );              // slot for LED flasher
  LOGIC_THRESHOLD  = p.get<unsigned short>( "LogicThreshold", 200 );       // threshold for finding logic pulse
  COSMIC_THRESHOLD  = p.get<int>( "CosmicThreshold", 2348 );               // ~15 pe (with pe=20 ADC counts)
  SPE_SLOT         = p.get<unsigned short>( "WaveformSlot", 5 );           // Slot of waveforms used by pulse-finding method
  WINDOW_MINSIZE   = p.get<unsigned int>( "WindowMinSize", 500 );          // minimum length of readout window 
  baseline_start   = p.get<unsigned short>( "LeadingBaselineStart", 0 );   // first tick after logic pulse start that defines baseline window
  baseline_end     = p.get<unsigned short>( "LeadingBaselineEnd", 180 );   // last tick after lofic pulses start that defines baseline window
  baseline2_start  = p.get<unsigned short>( "TrailingBaselineStart", 210 );// first tick after logic pulse start that defines baseline window
  baseline2_end    = p.get<unsigned short>( "TrailingBaselineEnd", 260  ); // last tick after lofic pulses start that defines baseline window
  pulse_start      = p.get<unsigned short>( "PulseStart", 180 );           // first tick after logic pulse start that defines pulse window
  pulse_end        = p.get<unsigned short>( "PulseEnd", 210 );             // first tick after logic pulse start that defines pulse window
  OpDataModule     = p.get<std::string>( "OpDataModule", "pmtreadout" );   // Waveform Module name, to get waveforms
  DAQHeaderModule  = p.get<std::string>( "DAQHeaderModule", "daq" );       // DAQ header module name, to get timestamp
  SAVE_AVE_SPE     = p.get<bool>( "SaveAverageSPE", true );                // Make average SPE waveforms
  cfd_threshold    = p.get<double>( "CFDThreshold", 10.0 );                // threshold for pulse-finding algorithm in ADCs
  cfd_delay        = p.get<unsigned short>( "CFDDelay", 4 );               // delay for pulse-finding algorithm in ticks
  cfd_deadtime     = p.get<unsigned short>( "CFDDeadtime", 20 );           // deadtime for pulse-finding algorithm in ticks
  cfd_width        = p.get<unsigned short>( "CFDWidth", 20 );              // width for pulse-finding algorithm in ticks
  AVESPE_RMSLIMIT  = p.get<double>( "AveSPEBaselineRMScut", 2.0 );         // cut to use when selecting pulses to make average SPE waveforms
  fHandleOwnTFile  = p.get<bool>( "HandleOwnTFile", false );                // module manages its own rootfiles instead of using TFileService
  fAutoSlot        = p.get<bool>( "AutoFindWaveformSlot", true );          // if true, automatically determins slot to get waveform (to handle 2 or 3 FEM)

  // Data for each Beam Window
  event_nchfires = new std::vector<int>;
  event_lastcosmicwin = new std::vector<double>;
  event_lastsatcosmicwin = new std::vector<double>;

  if ( !fHandleOwnTFile ) {
    // User TFileService
    // Setup Analyzer File
    art::ServiceHandle<art::TFileService> out_file;

    // Flasher code
    fTouttree = out_file->make<TTree>("outtree","Analyzed Flasher Run Data");

    // Pulse Tree
    fTpulsetree = out_file->make<TTree>("pulsetree","Analyzed Pulses");

    // Event Tree
    fTevent = out_file->make<TTree>("eventtree", "Data about the event" );

    // Setup the branches of the above trees
    SetupBranches();

    // Ave SPE waveform
    hSPE_ave = new TH1D*[32];
    hSPE_norm = new TH1D*[32];
    for (int i=0; i<32; i++) {
      hspe_nfills[i] = 0;
      char hname[32];
      sprintf( hname, "hSPE_ave_femch%02d", i );
      hSPE_ave[i] = out_file->make<TH1D>(hname, "Average SPE waveform;ticks from disc. fire-delay-deadtime", (int)cfd_width, 0.0, (double)cfd_width );
      sprintf( hname, "hSPE_norm_femch%02d", i );
      hSPE_norm[i] = out_file->make<TH1D>(hname, "Normalization;ticks from disc. fire-delay-deadtime", (int)cfd_width, 0.0, (double)cfd_width );
      for (int j=0;j<cfd_width;j++)
      hSPE_norm[i]->SetBinContent( j+1, 1.0 );
    }
    
  }    
  else {
    // We will open a tree at the beginning of each subrun file
    fOutputActive = false;
  }
    
  
}

void SPEcalibration::SetupTFile( TFile* file ) {
  file->cd();
  fOutDir = file->mkdir("specalib");
  fOutDir->cd();

  std::cout << "[SPEcalibration] SetupTFile" << std::endl;
  fTouttree = new TTree( "outtree","Analyzed Flasher Run Data");
  fTpulsetree = new TTree("pulsetree","Analyzed Pulses");
  fTevent = new TTree("eventtree", "Data about the event" );
  hSPE_ave = new TH1D*[32];
  hSPE_norm = new TH1D*[32];
  for (int i=0; i<32; i++) {
    hspe_nfills[i] = 0;
    char hname[32];
    sprintf( hname, "hSPE_ave_femch%02d", i );
    hSPE_ave[i] = new TH1D(hname, "Average SPE waveform;ticks from disc. fire-delay-deadtime", (int)cfd_width, 0.0, (double)cfd_width );
    sprintf( hname, "hSPE_norm_femch%02d", i );
    hSPE_norm[i] = new TH1D(hname, "Normalization;ticks from disc. fire-delay-deadtime", (int)cfd_width, 0.0, (double)cfd_width );
    for (int j=0;j<cfd_width;j++)
      hSPE_norm[i]->SetBinContent( j+1, 1.0 );
  }
  fOutputActive = true;
}

void SPEcalibration::CloseoutTFile( TFile* file ) {
  if (!fOutputActive)
    return;

  std::cout << "[SPEcalibration] Closeout TFile" << std::endl;
  fOutDir->cd();
  fOutDir->ls();
  fTouttree->Write();
  fTpulsetree->Write();
  fTevent->Write();
  for (int i=0; i<32; i++) {
    hSPE_ave[i]->Write();
    hSPE_norm[i]->Write();
  }
  file->Close();
  fOutputActive = false;
}

void SPEcalibration::endJob() {
  if ( fHandleOwnTFile )
    CloseoutTFile( fOutfile );
}

void SPEcalibration::SetupBranches() {
  // assumes trees are setup properly

  // Flasher-based code
  fTouttree->Branch("run",          &irun,          "run/I");
  fTouttree->Branch("subrun",       &isubrun,       "subrun/I");
  fTouttree->Branch("event",        &ievent,        "event/I");
  fTouttree->Branch("opchannel",    &opchannel,     "opchannel/I");
  fTouttree->Branch("charge",       &charge ,       "charge/D");
  fTouttree->Branch("maxamp",       &maxamp,        "maxamp/D");
  fTouttree->Branch("baseline",     &ave_baseline,  "baseline/D");
  fTouttree->Branch("baselinerms",  &rms_baseline,  "baselinerms/D");
  fTouttree->Branch("baseline2",    &ave_baseline2, "baseline2/D");
  fTouttree->Branch("baselinerms2", &rms_baseline2, "baselinerms2/D");

  // pulse-finding based code
  fTpulsetree->Branch("run",          &irun,          "run/I");
  fTpulsetree->Branch("subrun",       &isubrun,       "subrun/I");
  fTpulsetree->Branch("event",        &ievent,        "event/I");
  fTpulsetree->Branch("opchannel",    &opchannel,     "opchannel/I");
  fTpulsetree->Branch("charge",       &charge ,       "charge/D");
  fTpulsetree->Branch("maxamp",       &maxamp,        "maxamp/D");
  fTpulsetree->Branch("baseline",     &ave_baseline,  "baseline/D");
  fTpulsetree->Branch("baselinerms",  &rms_baseline,  "baselinerms/D");
  fTpulsetree->Branch("baseline2",    &ave_baseline2, "baseline2/D");
  fTpulsetree->Branch("baselinerms2", &rms_baseline2, "baselinerms2/D");
  fTpulsetree->Branch("chmaxamp",     &event_maxamp,  "chmaxamp/D" );
  fTpulsetree->Branch("triggerbit",   &triggerbit,    "triggerbit/i");
  fTpulsetree->Branch("trigs",        trigs,          "trigs[10]/i");
  fTpulsetree->Branch("event_timestamp_sec", &event_timestamp_sec, "event_timestamp_sec/D" );
  fTpulsetree->Branch("event_timestamp_usec", &event_timestamp_usec, "event_timestamp_usec/D" );
  fTpulsetree->Branch("wfm_unixtime", &wfm_unixtime, "wfm_unixtime/D" );
  fTpulsetree->Branch("pulse_unixtime", &pulse_unixtime, "pulse_unixtime/D" );

  // event data
  fTevent->Branch("run",        &irun,        "run/I");
  fTevent->Branch("subrun",        &isubrun,        "subrun/I");
  fTevent->Branch("event",    &ievent,       "event/I");
  fTevent->Branch("nsamples", &nsamples,     "nsamples/I" );
  fTevent->Branch("triggerbit",   &triggerbit,    "triggerbit/i");
  fTevent->Branch("trigs",        trigs,         "trigs[10]/i");
  fTevent->Branch("event_timestamp_sec", &event_timestamp_sec, "event_timestamp_sec/D" );
  fTevent->Branch("event_timestamp_usec", &event_timestamp_usec, "event_timestamp_usec/D" );
  fTevent->Branch("wfm_unixtime", &wfm_unixtime, "wfm_unixtime/D" );
  fTevent->Branch("chmaxamp", &event_maxamp, "chmaxamp/D");
  fTevent->Branch("nchfires", "vector<int>", &event_nchfires );
  fTevent->Branch("dt_lastcosmicwin_usec",    "vector<double>", &event_lastcosmicwin );
  fTevent->Branch("dt_lastsatcosmicwin_usec", "vector<double>", &event_lastsatcosmicwin );

  // Tree for PMT slam events (planned)
  // fTslam = out_file->make<TTree>("slamtree", "Data about fully staurated PMT events" );
  // slam_chtstamp = new std::vector<double>;
  // fTslam->Branch("event",     &ievent,          "event/I");
  // fTslam->Branch( "chtstamp", "vector<double>", &slam_chtstamp );  
}

void SPEcalibration::beginSubRun( art::SubRun const& sr){
  art::RunNumber_t run = sr.run();
  art::SubRunNumber_t subrun = sr.subRun();

  if ( fHandleOwnTFile ) {
    char filename[1048];
    sprintf( filename, "SPEcalibration_run%05d_subrun%05d.root", (int)run, (int)subrun );
    std::cout << "[SPEcalibration] Open TFile " << filename << std::endl;
    fOutfile = new TFile( filename, "RECREATE" );
    SetupTFile( fOutfile );
    SetupBranches();
  }
}

void SPEcalibration::endSubRun( art::SubRun const& sr){
  //art::RunNumber_t run = sr.run();
  //art::SubRunNumber_t subrun = sr.subRun();

  if ( fHandleOwnTFile ) {
    CloseoutTFile( fOutfile );
  }
}


void SPEcalibration::analyze(const art::Event& evt)
{
  // Run both routines
  irun    = (int)evt.run();
  isubrun = (int)evt.subRun();
  ievent    = (int)evt.event();
  //if ( !USE_PULSE_FINDER )
  anayzeLEDPulserMode( evt );    
  //else
  analyzePulseFindingMode( evt );

}


void SPEcalibration::anayzeLEDPulserMode(const art::Event& evt)
{
  // initialize data handles and services
  art::ServiceHandle<geo::UBOpReadoutMap> ub_PMT_channel_map;
  art::Handle< std::vector< raw::OpDetWaveform > > LogicHandle;
  art::Handle< std::vector< raw::OpDetWaveform > > wfHandle;

  evt.getByLabel( OpDataModule, "OpdetBeamHighGain", wfHandle);
  evt.getByLabel( OpDataModule, "UnspecifiedLogic" , LogicHandle);
  std::vector<raw::OpDetWaveform> const& opwfms(*wfHandle);
  std::vector<raw::OpDetWaveform> const& logwfms(*LogicHandle);
  
  ub_PMT_channel_map->SetOpMapRun( evt.run() );

  for(auto &wfm : logwfms)  {

    readout_ch = wfm.ChannelNumber();
    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    slot = (int)s;
    ch = (int)f;

    if(slot == (int)LOGIC_SLOT && ch == (int)LOGIC_CH) {

      flasher_adcs.clear();
      for(auto &adc : wfm)
	flasher_adcs.push_back( (short)adc );
      break;
    }

  }

  LogicPulseFinder<unsigned short> LPF;
  std::vector<unsigned short> ttlpulses;
  ttlpulses = LPF.Get_TTL_Starts(flasher_adcs, LOGIC_THRESHOLD);


  for(auto &wfm : opwfms)  {

    readout_ch = wfm.ChannelNumber();
    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    opchannel = (int)f;

    adcs.clear();
    for(auto &adc : wfm)
      adcs.push_back( (short)adc );


    //These four vectors will be filled in the next loop with baseline information, one baseline preceding and one                                          
    //following the pulse region                                                                                                                            

    std::vector<double> baseline_avgs;
    std::vector<double> baseline_vars;
    std::vector<double> baseline_avgs2;
    std::vector<double> baseline_vars2;

    for ( unsigned int ipulse=0; ipulse<ttlpulses.size(); ipulse++ ) {

      double x = 0.;
      double xx = 0.;
      double ticks = 0;
      for ( unsigned int tdc=ttlpulses.at(ipulse)+baseline_start; tdc<ttlpulses.at(ipulse)+baseline_end; tdc++ ) {
	if ( tdc>=adcs.size() )
	  break;
	x += (double)adcs.at( tdc );
	xx += ((double)adcs.at( tdc ))*((double)adcs.at(tdc));
	ticks += 1.0;
      }

      baseline_vars.push_back(sqrt( xx/ticks - (x/ticks)*(x/ticks) ));
      baseline_avgs.push_back(x / ticks);

      double x2 = 0.;
      double xx2 = 0.;
      double ticks2 = 0;

      for( unsigned int tdc=ttlpulses.at(ipulse) + baseline2_start; tdc<ttlpulses.at(ipulse)+baseline2_end; tdc++) {

	if (tdc>=adcs.size())
	  break;
	x2 += (double)adcs.at(tdc);
	xx2 += ((double)adcs.at(tdc))*((double)adcs.at(tdc));
	ticks2 += 1.0;

      }

      baseline_vars2.push_back(sqrt(xx2/ticks2 - (x2/ticks2)*(x2/ticks2)));
      baseline_avgs2.push_back(x2/ticks2);

    }

    //-----------------------------------------------------------------------------------------------------------                                           
    // Now that we have baseline information, we proceed to deal with the pulse region. Following we integrate                                              
    // and find the amplitude in the pulse region and use the baseline information to correct it                                                            

    for (unsigned int ipulse=0; ipulse<ttlpulses.size(); ipulse++ ) {
      unsigned int start = ttlpulses.at(ipulse)+pulse_start;
      unsigned int end   = ttlpulses.at(ipulse)+pulse_end;

      if ( end > adcs.size() )
	end = adcs.size();

      double ch_charge = 0.0;
      maxamp = -1;

      for (unsigned int i=start; i<end; i++ ) {
	
	ch_charge += adcs.at(i)-baseline_avgs[ipulse];
	
	if ( maxamp<adcs.at(i)-baseline_avgs[ipulse] )
	  maxamp = adcs.at(i)-baseline_avgs[ipulse];

      }

      // ------------------------------------------------------------------------------------------------------                
      // Fill the output tree with all the goodies we have calculated here                                                                                
      ave_baseline  = baseline_avgs[ipulse];                                                                                                              
      ave_baseline2 = baseline_avgs2[ipulse];                                                                                                             
      rms_baseline  = baseline_vars[ipulse];                                                                                                              
      rms_baseline2 = baseline_vars2[ipulse];                                                                                                             
      charge        = ch_charge;                                                                                                                          
      // ----------------------------------------------------------------                                                                                 
      fTouttree->Fill(); 
  
    }

  }

}

void SPEcalibration::analyzePulseFindingMode(const art::Event& evt)
{
  // initialize data handles and services
  art::ServiceHandle<geo::UBOpReadoutMap> ub_PMT_channel_map;
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();
  art::Handle< std::vector< raw::OpDetWaveform > > LogicHandle;
  art::Handle< std::vector< raw::OpDetWaveform > > wfHandle;
  art::Handle< raw::DAQHeader > dhHandle;
  art::Handle< std::vector< raw::Trigger > > trigHandle;

  evt.getByLabel( OpDataModule, "OpdetBeamHighGain", wfHandle);
  std::vector<raw::OpDetWaveform> const& opwfms(*wfHandle);

  evt.getByLabel( DAQHeaderModule, dhHandle );
  evt.getByLabel( DAQHeaderModule, trigHandle );

  ub_PMT_channel_map->SetOpMapRun( evt.run() );

  event_maxamp = 0.0;
  event_nchfires->clear();
  event_nchfires->resize( 32, 0.0 );
  event_lastcosmicwin->clear();
  event_lastcosmicwin->resize( 32, 1.0 );
  event_lastsatcosmicwin->clear();
  event_lastsatcosmicwin->resize( 32, 1.0 );
  nsamples = 0;

  // get trigger time
  double trig_timestamp = ts->TriggerTime(); // usec from beginning of run (or subrun?)

  // event timestamp
  const raw::DAQHeader& dh = (*dhHandle);
  time_t daq_timestamp = dh.GetTimeStamp();
  event_timestamp_sec = (double)(daq_timestamp>>32);
  event_timestamp_usec  = 0.001*(double)( daq_timestamp & 0xFFFFFFFF );
  
  // trigger bit
  const std::vector< raw::Trigger >& trigvec = (*trigHandle);
  const raw::Trigger& trig = trigvec.at(0);

  // From uboone/RawData/util/LArRawInputDriverUBooNE.cxx
  // uint32_t trig_bits = trig_data.getPMTTrigData();
  // if( trig_data.Trig_PC()       ) trig_bits += ( 0x1 << ::trigger::kTriggerPC    );
  // if( trig_data.Trig_EXT()      ) trig_bits += ( 0x1 << ::trigger::kTriggerEXT   );
  // if( trig_data.Trig_Active()   ) trig_bits += ( 0x1 << ::trigger::kActive       );
  // if( trig_data.Trig_Gate1()    ) trig_bits += ( 0x1 << ::trigger::kTriggerNuMI  );
  // if( trig_data.Trig_Gate2()    ) trig_bits += ( 0x1 << ::trigger::kTriggerBNB   );
  // if( trig_data.Trig_Veto()     ) trig_bits += ( 0x1 << ::trigger::kVeto         );
  // if( trig_data.Trig_Calib()    ) trig_bits += ( 0x1 << ::trigger::kTriggerCalib );
  // if( trig_data.Trig_GateFake() ) trig_bits += ( 0x1 << ::trigger::kFakeGate     );
  // if( trig_data.Trig_BeamFake() ) trig_bits += ( 0x1 << ::trigger::kFakeBeam     );
  // if( trig_data.Trig_Spare1()   ) trig_bits += ( 0x1 << ::trigger::kSpare        );

  triggerbit = trig.TriggerBits();
  for (int i=0; i<10; i++)
    trigs[i] = 0;
  trigs[0] = triggerbit & ( 0x1 << ::trigger::kTriggerPC);
  trigs[1] = triggerbit & ( 0x1 << ::trigger::kTriggerEXT);
  trigs[2] = triggerbit & ( 0x1 << ::trigger::kActive );
  trigs[3] = triggerbit & ( 0x1 << ::trigger::kTriggerNuMI );
  trigs[4] = triggerbit & ( 0x1 << ::trigger::kTriggerBNB );
  trigs[5] = triggerbit & ( 0x1 << ::trigger::kVeto );
  trigs[6] = triggerbit & ( 0x1 << ::trigger::kTriggerCalib );
  trigs[7] = triggerbit & ( 0x1 << ::trigger::kFakeGate );
  trigs[8] = triggerbit & ( 0x1 << ::trigger::kFakeBeam );
  trigs[9] = triggerbit & ( 0x1 << ::trigger::kSpare );

  // auto-slot
  unsigned int autoslot = 0;
  if ( fAutoSlot ) {
    // this is hacky
    // we use the readout channel 0 to determine which slot provides high-gain waveforms
    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(0, c, s, f);
    autoslot = s;
  }
  
  // get channel maxamp and other event related info
  for(auto &wfm : opwfms)  {
    readout_ch = wfm.ChannelNumber();
    if ( readout_ch%100>=32 )
      continue;

    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    slot = (int)s;
    ch = (int)f;
    if ( (!fAutoSlot && slot!=(int)SPE_SLOT) || (fAutoSlot && slot!=(int)autoslot ) )
      continue;
    if ( WINDOW_MINSIZE < wfm.size() ) {
      // beam window
      nsamples = (int)wfm.size();
      for (int i=0; i<(int)wfm.size(); i++) {
	if ( event_maxamp<(double)wfm.at(i) )
	  event_maxamp = (double)wfm.at(i);
      }
      wfm_unixtime = wfm.TimeStamp();
    }
    else {
      // cosmic window. we have a cosmic threshold (to prevent considering late or smaller light pulses)
      double dt_usec = wfm.TimeStamp()-trig_timestamp; // usec
      wfm_unixtime = wfm.TimeStamp();
      pulse_unixtime = wfm.TimeStamp();
      auto maxelem = std::max_element( wfm.begin(), wfm.end() );
      //std::cout << " " << ch << ", " << wfm.size() << ": " << dt_usec << " " << wfm.TimeStamp() << " " << trig_timestamp << " " << *maxelem << std::endl;
      if ( dt_usec>0 )
	continue;

      if ( (int)(*maxelem)>COSMIC_THRESHOLD ) {
	if ( event_lastcosmicwin->at(ch) > 0.0 || std::fabs(dt_usec)<std::fabs(event_lastcosmicwin->at(ch)) ) {
	  event_lastcosmicwin->at(ch) = dt_usec;
	}
	if ( (int)(*maxelem)>4090 ) {
	  // saturated channel
	  if ( event_lastsatcosmicwin->at(ch)>0.0 || (std::fabs(dt_usec)<std::fabs(event_lastsatcosmicwin->at(ch)) ) ) {
	    event_lastsatcosmicwin->at(ch) = dt_usec;
	  }
	}
      }//end of if cosmic threshold met
    }
  }
  
  
  for(auto &wfm : opwfms)  {
    readout_ch = wfm.ChannelNumber();

    if ( WINDOW_MINSIZE > wfm.size() )
      continue;
    nsamples = (int)wfm.size();

    unsigned int c,s,f;
    ub_PMT_channel_map->GetCrateSlotFEMChFromReadoutChannel(readout_ch, c, s, f);
    slot = (int)s;
    ch = (int)f;
    if ( (!fAutoSlot && slot!=(int)SPE_SLOT) || (fAutoSlot && slot!=(int)autoslot ) )
      continue;

    // convert waveform
    std::vector<double> data;
    for (int i=0; i<(int)wfm.size(); i++)
      data.push_back( (double)wfm.at(i) );

    // get pulse positions
    std::vector< int > t_fire;
    std::vector< int > amp_fire;
    std::vector< int > maxt_fire;
    std::vector< int > diff_fire;
    cpysubevent::runCFdiscriminatorCPP( t_fire, amp_fire, maxt_fire, diff_fire,
					data.data(), (int)cfd_delay, (int)cfd_threshold, (int)cfd_deadtime, (int)cfd_width, (int)data.size() );

    wfm_unixtime = wfm.TimeStamp();
    pulse_unixtime = wfm.TimeStamp();

    // we loop through the pulses.  
    if ( ch<32 )
      event_nchfires->at( ch ) = (int)t_fire.size();
    for ( int ifire=0; ifire<(int)t_fire.size(); ifire++ ) {

      int tick = (int)t_fire.at(ifire) - (int)cfd_delay;
      if ( tick<(int)2*cfd_deadtime || tick>(int)wfm.size()-(int)2*cfd_deadtime 
	   || ( ifire>0 && tick < t_fire.at(ifire-1)+(int)2*cfd_deadtime ) ) {
	// only use pulses 2 times the deadtime from the ends and 2 deadtimes away from the previous pulse
	continue;
      }
      
      // ok we like this one. baseline time. also save maximum amplitude of channel
      ave_baseline = 0.;
      rms_baseline = 0.;
      ave_baseline2 = 0.;
      rms_baseline2  = 0.;
      for (int i=0; i<(int)cfd_width; i++) {
	ave_baseline += (double)wfm.at( tick-cfd_width+i );
	rms_baseline  += (double)wfm.at( tick-cfd_width+i )*wfm.at( tick-cfd_width+i );
	ave_baseline2  += (double)wfm.at( tick+cfd_width+i );
	rms_baseline2 += (double)wfm.at( tick+cfd_width+i )*wfm.at( tick+cfd_width+i );
      }
      ave_baseline /= (double)cfd_width;
      ave_baseline2  /= (double)cfd_width;
      rms_baseline /= (double)cfd_width;
      rms_baseline2 /= (double)cfd_width;
      rms_baseline = sqrt( rms_baseline - ave_baseline*ave_baseline );
      rms_baseline2 = sqrt( rms_baseline2 - ave_baseline2*ave_baseline2 );

      // calculate integral
      maxamp = 0.0;
      charge = 0.0;
      double baseline_slope = (ave_baseline2-ave_baseline)/(double)cfd_width;
      for (int i=0; i<(int)cfd_width; i++) {
	double adc = wfm.at( tick + i ) - (baseline_slope*(i) + ave_baseline);
	charge += adc;
	if ( adc>maxamp )
	  maxamp = adc;
	if ( ch<32 && rms_baseline<AVESPE_RMSLIMIT && rms_baseline2<AVESPE_RMSLIMIT ) {
	  hSPE_ave[ch]->SetBinContent( i+1, (hSPE_ave[ch]->GetBinContent( i+1 )*hspe_nfills[ch] + adc)/double(hspe_nfills[ch]+1) );
	}
      }
      if ( ch<32 && rms_baseline<AVESPE_RMSLIMIT && rms_baseline2<AVESPE_RMSLIMIT )
	hspe_nfills[ch]++;

      // ok done for the pulse
      opchannel = readout_ch;

      // pulses
      pulse_unixtime = wfm.TimeStamp() + tick*0.015625; // usec

      fTpulsetree->Fill();
    }
  } //end of loop over waveforms

  fTevent->Fill();
}


DEFINE_ART_MODULE(SPEcalibration)
