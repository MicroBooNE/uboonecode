////////////////////////////////////////////////////////////////////////
// Class:       SubEventBuilder
// Module Type: SubEventBuilder
// File:        SubEventBuilder_module.cc
//
// Generated at Thu Oct  8 13:18:22 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <set>
#include <map>
#include <vector>
#include <iostream>

// LArSoft
#include "RawData/OpDetWaveform.h"
#include "RecoBase/OpFlash.h"
#include "RecoBase/OpHit.h"
#include "Utilities/AssociationUtil.h"
#include "Utilities/TimeService.h"
#include "Geometry/Geometry.h"
#include "Geometry/OpDetGeo.h"

#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/FlashList.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEvent.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventList.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventModule.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventModConfig.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/WaveformData.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/CosmicWindowSubEvents.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/pedestal.hh"

class SubEventBuilder;

class SubEventBuilder : public art::EDProducer {
public:
  explicit SubEventBuilder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SubEventBuilder(SubEventBuilder const &) = delete;
  SubEventBuilder(SubEventBuilder &&) = delete;
  SubEventBuilder & operator = (SubEventBuilder const &) = delete;
  SubEventBuilder & operator = (SubEventBuilder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  std::string fOpDetInputModule;
  subevent::SubEventModConfig fConfig;
  bool fMakeOpFlash;
  double fTrigCoinc;
  int fBeamWinLengthThreshold;
  double fRC;
  double fA;

  bool sortWaveforms( art::Event& event, subevent::WaveformData& hgbeam, subevent::WaveformData& lgbeam, subevent::CosmicWindowHolder& cosmics, int beamwin_len_threshold );
  void prepCosmicDiscWaveforms(  subevent::CosmicWindowHolder& cosmics ); 
  void prepBeamWaveforms( art::Event& event, subevent::WaveformData& hgwfms, subevent::WaveformData& lgwfms, subevent::SubEventList& cosmic_subevents );
  // bool gatherWaveforms( art::Event& event, subevent::WaveformData& wfms );
  // void baselineCorrectWaveforms( subevent::WaveformData& wfms );
  // void makeOpFlashes( art::Event& e, subevent::SubEventList& subevents, subevent::WaveformData& wfms );
  // void GetHitGeometryInfo(subevent::Flash const& flash,
  // 			  geo::Geometry const& geom,
  // 			  std::vector<double> & sumw,
  // 			  std::vector<double> & sumw2,
  // 			  double & sumy, double & sumy2,
  // 			  double & sumz, double & sumz2);
  
  
};


SubEventBuilder::SubEventBuilder(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{

  fOpDetInputModule           = p.get<std::string>( "inputModule");
  fMakeOpFlash                = p.get<bool>( "makeOpFlash", true );
  fTrigCoinc                  = p.get<double>       ("TrigCoinc");
  fBeamWinLengthThreshold     = p.get<int>( "BeamWinLengthThreshold", 500 );

  fConfig.cfdconfig.threshold = p.get<int>( "threshold" );
  fConfig.cfdconfig.deadtime  = p.get<int>( "deadtime" );
  fConfig.cfdconfig.delay     = p.get<int>( "delay" );
  fConfig.cfdconfig.width     = p.get<int>( "width" );
  fConfig.cfdconfig.gate      = p.get<int>( "gate" );
  fConfig.cfdconfig_pass2.threshold = p.get<int>( "pass2_threshold" );
  fConfig.cfdconfig_pass2.deadtime  = p.get<int>( "pass2_deadtime" );
  fConfig.cfdconfig_pass2.delay     = p.get<int>( "pass2_delay" );
  fConfig.cfdconfig_pass2.width     = p.get<int>( "pass2_width" );
  fConfig.cfdconfig_pass2.gate      = p.get<int>( "pass2_gate" );
  fConfig.fastfraction        = p.get<double>( "fastfraction", 0.8 );
  fConfig.slowfraction        = p.get<double>( "slowfraction", 0.3 );
  fConfig.fastconst_ns        = p.get<double>( "fastconst_ns", 6.0 );
  fConfig.slowconst_ns        = p.get<double>( "slowconst_ns", 1600.0 );
  fConfig.noslowthreshold     = p.get<double>( "noslowthreshold", 40.0 );
  fConfig.pedsamples          = p.get<int>( "pedsamples", 100 );
  fConfig.npresamples         = p.get<int>( "npresamples", 5 );
  fConfig.maxchflashes        = p.get<int>( "maxchflashes", 30 );
  fConfig.pedmaxvar           = p.get<double>( "pedmaxvar", 1.0 );
  fConfig.spe_sigma           = p.get< double >( "spe_sigma", 15.625*4.0 );
  fConfig.hgslot              = p.get<int>( "hgslot", 5 );
  fConfig.lgslot              = p.get<int>( "lgslot", 6 );
  fConfig.flashgate           = p.get<int>( "flashgate", 10 );
  fConfig.maxsubeventloops    = p.get<int>( "maxsubeventloops", 50 );
  fConfig.ampthresh           = p.get<double>( "ampthresh" );
  fConfig.hitthresh           = p.get<int>( "hitthresh" );
  fConfig.nspersample         = p.get<double>( "nspersample", 15.625 );

  // Call appropriate produces<>() functions here.
  produces< std::vector< subevent::SubEvent > >();
  produces< subevent::FlashList >( "unclaimedFlashes" );

  if ( fMakeOpFlash ) {
    produces<std::vector< recob::OpFlash> >();
    produces<std::vector< recob::OpHit> >();
    produces<art::Assns<recob::OpFlash, recob::OpHit> >();
  }
}

void SubEventBuilder::produce(art::Event & e)
{
  // Implementation of required member function here.  

  // get waveforms
  subevent::WaveformData hgwfms;
  subevent::WaveformData lgwfms;
  subevent::CosmicWindowHolder cosmicwins;
  bool ok = sortWaveforms( e, hgwfms, lgwfms, cosmicwins, fBeamWinLengthThreshold );
  if (!ok) {
    std::cout << "trouble loading waveforms!" << std::endl;
    return;
  }

  // We form subevents using just the cosmic discriminator windows
  subevent::SubEventList cosmic_subevents;
  prepCosmicDiscWaveforms( cosmicwins );
  subevent::formCosmicWindowSubEvents( cosmicwins, fConfig, cosmic_subevents );
  std::cout << "Cosmic Disc. Subevents found: " << cosmic_subevents.size() << std::endl;
  
  // get waveforms and prep them
  prepBeamWaveforms( e, hgwfms, lgwfms, cosmic_subevents );

  // declare containers for beam subevent output
  subevent::SubEventList subevents;
  std::unique_ptr< subevent::FlashList > unclaimed_flashes( new subevent::FlashList() );

  // hack: make spe calibration table
  std::map< int, double > pmtspemap;
  for (int i=0; i<36; i++)
    pmtspemap[i] = 20.0;
  
  // Find subevents
  //formSubEvents( wfms, fConfig, pmtspemap, subevents, *unclaimed_flashes );
  //std::cout << "subevents formed. now store in event." << std::endl;
  
  // make opflash
  // if ( fMakeOpFlash ) {
  //   //makeBeamOpFlashes( e, subevents, wfms );
  //   //makeCosmicOpFlashes( e, cosmic_subevents );
  // }

  // transfer subevents to the event
  //std::unique_ptr< std::vector< subevent::SubEvent > > subeventvec( new std::vector< subevent::SubEvent > );
  // for ( subevent::SubEventListIter it=subevents.begin(); it!=subevents.end(); it++ ) {
  //   subeventvec->emplace_back( *it );
  // }
  // e.put( std::move( subeventvec ) );
  // e.put( std::move( unclaimed_flashes ), "unclaimedFlashes" );
  
}

bool SubEventBuilder::sortWaveforms( art::Event& event, subevent::WaveformData& hgbeam, subevent::WaveformData& lgbeam, subevent::CosmicWindowHolder& cosmics, int beamwin_len_threshold ) {
  // Load Services and Event Handles
  art::ServiceHandle<util::TimeService> ts;
  
  art::Handle< std::vector< raw::OpDetWaveform > > hgwfmHandle;
  bool loadedhg = event.getByLabel( fOpDetInputModule, "OpdetBeamHighGain", hgwfmHandle );
  
  art::Handle< std::vector< raw::OpDetWaveform > > lgwfmHandle;
  bool loadedlg = event.getByLabel( fOpDetInputModule, "OpdetBeamLowGain", lgwfmHandle );
  if ( !loadedhg || !loadedlg ) {
    std::cout << "Could not load optdet waveforms!" << std::endl;
    return false;
  }

  // get trigger and beamgate info
  double trig_timestamp = ts->TriggerTime();
  std::cout << "[SubEventBuilder] trig timestamp: " << trig_timestamp << std::endl;
  //unsigned int trig_frame = ts->OpticalClock().Frame( trig_timestamp );
  //unsigned int trig_sample = ts->OpticalClock().Sample( trig_timestamp );
  //double beam_timestamp = ts->BeamGateTime();
  //unsigned int beam_frame = ts->OpticalClock().Frame( beam_timestamp );
  //unsigned int beam_sample = ts->OpticalClock().Sample( beam_timestamp );

  // Loop over High-Gain Waveforms
  for ( auto const& opdetData: (*hgwfmHandle) ) {

    // get window info
    raw::Channel_t channel = opdetData.ChannelNumber()%100;
    double timestamp = opdetData.TimeStamp();      

    if ( ((int)opdetData.size()) < beamwin_len_threshold ) {
      // cosmic windows: want to store ticks since trigger
      int ticks = (int)(timestamp - trig_timestamp)/ts->OpticalClock().TickPeriod();
      //std::cout << "cosmic window start=" << ticks << " (ticks)" << std::endl;
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      cosmics.addHG( (int)channel, ticks, wfm );
    }
    else {
      // beam windows: store timestamp
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      hgbeam.set( (int)channel, wfm, false );
      // store time stamp for later
      hgbeam.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );
    }
  }

  // Loop over Low-Gain Waveforms
  for ( auto const& opdetData: (*lgwfmHandle) ) {

    // get window info
    raw::Channel_t channel = opdetData.ChannelNumber();
    double timestamp = opdetData.TimeStamp();      

    if ( ((int)opdetData.size()) < beamwin_len_threshold ) {
      // cosmic windows: want to store ticks since trigger
      int ticks = (int)(timestamp - trig_timestamp)/ts->OpticalClock().TickPeriod();
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      cosmics.addLG( (int)channel, ticks, wfm );
    }
    else {
      // beam windows: store timestamp
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      lgbeam.set( (int)(channel), wfm, false );
      // store time stamp for later
      lgbeam.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );
    }
  }
  
  
  return true;
}
  
void SubEventBuilder::prepCosmicDiscWaveforms( subevent::CosmicWindowHolder& cosmics ) {
  // we sort, remove the pedestal, scale up low gain, and replace saturated high gain waveforms with low gain waveforms
  cosmics.sort();

  // prep low gain waveforms
  for ( subevent::CosmicWfmMapIter it=cosmics.lowGainWfmMap.begin(); it!=cosmics.lowGainWfmMap.end(); it++ ) {
    for ( std::vector<double>::iterator iadc=(*it).second.begin(); iadc!=(*it).second.end(); iadc++ ) {
      (*iadc) -= 2047.0; // remove pedestal;
      (*iadc) *= 10.0;   // scale up for low gain
    }
  } // end of lowgain loop

  // prep high gain waveforms
  for ( subevent::CosmicWfmMapIter it=cosmics.highGainWfmMap.begin(); it!=cosmics.highGainWfmMap.end(); it++ ) {
    // remove pedestal
    double maxadc = 0.0;
    for ( unsigned iadc=0; iadc<(*it).second.size(); iadc++ ) {
      (*it).second.at(iadc) -= 2047.0;
      if ( (*it).second.at(iadc) > maxadc ) {
	maxadc = (*it).second.at(iadc);
      }
      if ( maxadc > 2020.0 ) {
	break; // we can stop, because we will replace this waveform
      }
    }

    if ( maxadc>2020.0 ) {
      maxadc = 0;
      // switch to low gain waveform
      subevent::CosmicWinIndex lgindex = cosmics.getLGindexFromHG( (*it).first );
      std::vector< double >& lgwfm = cosmics.lowGainWfmMap[ lgindex ];
      // overwrite high gain
      (*it).second.clear();
      (*it).second.reserve( lgwfm.size() );
      for ( unsigned iadc=0; iadc<lgwfm.size(); iadc++ ) {
	(*it).second.push_back(lgwfm.at(iadc) );
	if ( lgwfm.at(iadc) > maxadc ) {
	  maxadc = lgwfm.at(iadc);
	}
      }
    }//if saturated, replace 
  }//end of high gain loop
} // end of prepCosmicDiscWaveforms

void SubEventBuilder::prepBeamWaveforms( art::Event& event, subevent::WaveformData& hgwfms, subevent::WaveformData& lgwfms, subevent::SubEventList& cosmicsubevents ) {
  // get services
  art::ServiceHandle<util::TimeService> ts;

  // first replace hgwfms that saturate and remove pedestal
  for ( subevent::ChannelSetIter it=hgwfms.chbegin(); it!=hgwfms.chend(); it++ ) {
    std::vector< double >& wfm = hgwfms.get( *it );
    bool replace = false;
    for ( auto adc : wfm ) {
      if ( adc > 4050 ) {
	replace = true;
	break;
      }
    }
    if ( replace ) {
      // remove low gain pedestal and scale by a factor of 10.0
      hgwfms.get( *it ).clear();
      std::vector< double >& lgwfm = lgwfms.get( *it );
      subevent::removePedestal( lgwfm, 20, 2.0, 2047.0 );
      hgwfms.get( *it ).reserve( lgwfm.size() );
      for ( auto adc : lgwfm )
	hgwfms.get( *it ).push_back( 10.0*adc );
      std::cout << " replaced hg with lowgain channel: size=" <<  hgwfms.get( *it ).size() << " lgwfmsize=" << lgwfm.size() << std::endl;
      hgwfms.setLowGain( *it, true );
    }
    else {
      // remove high gain pedestal only
      subevent::removePedestal( hgwfms.get( *it ), 20.0, 2.0, 2047.0 );
    }
  } //end of channel loop
  
  // look for cosmic discriminator windows that cross into the boundary of the beam window
  subevent::SubEvent* boundarysubevent = NULL;
  int closest = 0;
  for ( subevent::SubEventListIter it=cosmicsubevents.begin(); it!=cosmicsubevents.end(); it++ ) {
    if ( (*it).tstart_sample<0 && (*it).tend_sample>0 ) {
      std::cout << "[SubEventBuilder] found boundary subevent candidate, tstart=" << (*it).tstart_sample << " tend=" << (*it).tend_sample << " (ticks)" << std::endl;
      if ( boundarysubevent==NULL || -(*it).tstart_sample < closest ) {
	boundarysubevent = &(*it);
	closest = -(*it).tstart_sample;
      }
    }
  }
  
  // if we found a boundary subevent, we correct the baseline
  std::map< int, int > baseline_correction_start;
  if ( boundarysubevent ) {
    std::cout << "[SubEventBuilder] boundary subevent, tstart=" << boundarysubevent->tstart_sample << " tend=" << boundarysubevent->tend_sample << " (ticks)" << std::endl;
    double f = exp( -fConfig.nspersample/fRC );

    for ( subevent::FlashListIter iflash=boundarysubevent->flashes.begin(); iflash!=boundarysubevent->flashes.end(); iflash++ ) {
      int ch = (*iflash).ch;
      std::vector< double > vcorr( 1, 0.0 );
      // use the expectation to make the correction, because we don't have the actual waveform unfortunately
      for ( unsigned int iadc=1; iadc<(*iflash).expectation.size(); iadc++ ) {
	double q = (*iflash).expectation.at(iadc)*fA*(fConfig.nspersample/fRC) + vcorr.at( iadc-1 )*f;
	vcorr.push_back( q );
      }
      // extend until we fall below 1 adc
      unsigned int iadc = vcorr.size()-1;
      while ( vcorr.at(iadc) > 1.0 ) {
	double q = vcorr.at(iadc)*f;
	vcorr.push_back( q );
	iadc++;
      }
      // apply the correction
      std::vector< double >& beamwin = hgwfms.get( ch );
      int offset = int( ((*iflash).tstart*ts->OpticalClock().TickPeriod() - ts->TriggerTime())/ts->OpticalClock().TickPeriod() );
      int cosmic_start = std::max( 0, offset );
      int cosmic_len   = std::min( (int)vcorr.size()-cosmic_start, (int)beamwin.size() );
      for ( int iadc=cosmic_start; iadc<cosmic_start+cosmic_len; iadc++ ) {
	beamwin.at( iadc-cosmic_start ) -= vcorr.at( iadc );
      }
      if ( !hgwfms.isLowGain( ch ) )
	subevent::removePedestal( beamwin, 20.0, 2.0, 0.0 );
      else
	subevent::removePedestal( beamwin, 20.0, 20.0, 0.0 );
      // we save where we started. this is so that baseline correction from charge inside beam window doesn't double count the correction we just made
      baseline_correction_start[ ch ] = cosmic_len;
    }//end of loop over flashes/channels
  }// end of if boundary event

  // baseline correct other waveforms
  double f = exp( -fConfig.nspersample/fRC );
  for ( subevent::ChannelSetIter it=hgwfms.chbegin(); it!=hgwfms.chend(); it++ ) {
    int ch = (*it);
    std::vector< double >& wfm = hgwfms.get( ch );
    // determine start of correction
    int correction_start = 1;
    if ( baseline_correction_start.find( ch )!=baseline_correction_start.end() )
      correction_start = baseline_correction_start[ch];
    if ( correction_start<1 )
      correction_start = 1;
    // calculate size of correction
    std::vector< double > vcorr( wfm.size(), 0.0 );
    for ( int iadc=correction_start; iadc<(int)vcorr.size(); iadc++ ) {
      double q = wfm.at( iadc )*fA*fConfig.nspersample/fRC + vcorr.at( iadc-1 )*f;
      vcorr.at( iadc ) = q;
    }
    // apply correction
    for ( int iadc=0; iadc<(int)wfm.size(); iadc++ )
      wfm.at(iadc) += vcorr.at( iadc );
  }// end of loop over hg channels
  
  // finally we want to suppress the creation of subevents within the bounds of the boundary subevents. we do this by removing the waveform here
  if ( boundarysubevent ) {
    //int subevent_tend = int( (boundarysubevent->tend_sample*ts->OpticalClock().(TickPeriod()*1.0e6) - ts->TriggerTime())/ts->OpticalClock().TickPeriod() )+1;
    int subevent_tend = boundarysubevent->tend_sample; // samples from trigger
    // std::cout << "suppressing waveform from boundary subevent up to sample " << subevent_tend << " tend=" << boundarysubevent->tend_sample << " (ticks)" 
    // 	      << " " << boundarysubevent->tend_sample*ts->OpticalClock().TickPeriod()*1.0e6
    // 	      << " " << boundarysubevent->tend_sample*ts->OpticalClock().TickPeriod()*1.0e6 - ts->TriggerTime()
    // 	      << std::endl;
    for ( subevent::FlashListIter iflash=boundarysubevent->flashes.begin(); iflash!=boundarysubevent->flashes.end(); iflash++ ) {
      int ch = (*iflash).ch;
      std::vector< double >& wfm = hgwfms.get( ch );
      int channel_offset = int( (hgwfms.getTimestamp( ch ) - ts->TriggerTime() )/ts->OpticalClock().TickPeriod() );
      //double ped = calcPedestal( wfm, 20, 1.0, wfm.at(tend) );
      int tend = std::min(subevent_tend-channel_offset,(int)wfm.size());
      std::cout << "suppressing ch " << ch << " waveform from boundary subevent (tend=" << subevent_tend << ") up to sample " << tend << " of " << wfm.size() << " (channel offset=" << hgwfms.getTimestamp( ch ) - ts->TriggerTime() << ")" << std::endl;
      double ped = wfm.at(tend);
      for ( int iadc=0; iadc<tend; iadc++ ) {
  	wfm.at(iadc) = ped;
      }
      subevent::removePedestal( wfm, 20, 1.0, ped );
    }
  }
}

// bool SubEventBuilder::gatherWaveforms( art::Event& event, subevent::WaveformData& wfms, subevent::CosmicWindowHolder& cosmics ) {

//   // Load Services and Event Handles
//   art::ServiceHandle<util::TimeService> ts;

//   art::Handle< std::vector< raw::OpDetWaveform > > hgwfmHandle;
//   bool loadedhg = event.getByLabel( fOpDetInputModule, "OpdetBeamHighGain", hgwfmHandle );
  
//   art::Handle< std::vector< raw::OpDetWaveform > > lgwfmHandle;
//   bool loadedlg = event.getByLabel( fOpDetInputModule, "OpdetBeamLowGain", lgwfmHandle );

//   if ( !loadedhg || !loadedlg ) {
//     std::cout << "Could not load optdet waveforms!" << std::endl;
//     return false;
//   }

//   // temp storage variables
//   std::vector< double > wfmstore;
//   std::set< int > use_lowgain_wfm;

//   // Loop over High-Gain Waveforms
//   unsigned int biggestcosmiclen = 0;
//   unsigned int beamwinlen = 0;
//   double shortestdt = 1e10;
//   for ( auto const& opdetData: (*hgwfmHandle) ) {
//     // if ( opdetData.size()<600 ) { // arbitrary!
//     //   // COSMIC WINDOW STORE
//     //   if ( opdetData.size()>biggestcosmiclen )
//     // 	biggestcosmiclen = opdetData.size();
//     //   //std::cout << "skipping cosmic window: " << opdetData.size() << std::endl;
//     //   double dtcosmic = opdetData.TimeStamp() - ts->BeamGateTime();
//     //   if ( fabs( dtcosmic )<shortestdt )
//     // 	shortestdt = fabs( dtcosmic );
//     //}

//     raw::Channel_t channel = opdetData.ChannelNumber();
//     wfmstore.clear();

//     if ( wfmstore.size() != opdetData.size() ) {
//       wfmstore.reserve( opdetData.size() );
//     }
//     if ( beamwinlen<opdetData.size() )
//       beamwinlen = opdetData.size();
      
//     bool marked_for_lg = false;
//     double adcmax = 0.0;
//     //std::cout << " ch " << channel << ": ";
//     for ( auto adc: opdetData ) {
//       if ( !marked_for_lg && adc>4090 ) {
// 	marked_for_lg = true;
// 	use_lowgain_wfm.insert( (int)channel );
//       }
//       wfmstore.push_back( (double)adc );
//       //std::cout << adc << " ";
//       if ( adcmax < (double)adc )
// 	adcmax = (double)adc;
//     }
//     //std::cout << std::endl;
//     //double ped =  subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
//     subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
//     //std::cout << "  adc max: " << adcmax-ped << " pedestal=" << ped << std::endl;
//     wfms.set( (int)channel, wfmstore, false );
//     // store time stamp for later
//     wfms.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );

//     // Low-Gain Waveforms
//     if ( use_lowgain_wfm.size() > 0 ) {
//       for ( auto const& opdetData: (*lgwfmHandle) ) {
// 	if ( opdetData.size()<600 )
// 	  continue; // skip cosmic windows
// 	raw::Channel_t channel = opdetData.ChannelNumber();
// 	if ( use_lowgain_wfm.find( (int)channel )!=use_lowgain_wfm.end() ) {
// 	  // marked to replace hg
// 	  wfmstore.clear();
// 	  double adcmax = 0.0;
// 	  std::cout << " LG ch " << channel << ": ";
// 	  for ( auto adc: opdetData ) {
// 	    wfmstore.push_back( (double)adc );
// 	    if ( adcmax < (double)adc )
// 	      adcmax = (double)adc;
// 	  }
// 	  double ped = subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
// 	  std::cout << "  adc max: " << 10.0*(adcmax-ped) << " pedestal=" << ped << std::endl;
	  
// 	  // scale up
// 	  for (int i=0; i<(int)wfmstore.size(); i++ )
// 	    wfmstore.at(i) *= 10.0;
	  
// 	  wfms.set( (int)channel, wfmstore, true ); // low gain waveform
// 	}// if marked for lg replacement
//       }// loop over lowgain waveforms
//     } // if replacements necessary

//     std::cout << "gathered beam waveforms: beamwin length=" << beamwinlen << " cosmicwin length=" << biggestcosmiclen << " shorteddt=" << shortestdt*1000 << " ns" << std::endl;
    
//   }
  
//   return true;
// }

// void SubEventBuilder::baselineCorrectWaveforms( subevent::WaveformData& wfms ) {
//   double RC = 50000.0; // ns
//   double f = exp( -15.625/RC );
//   std::vector< double > qcap;
  
//   for ( subevent::ChannelSetIter itch=wfms.chbegin(); itch!=wfms.chend(); itch++ ) {

//     // calc charge on capacitor
//     qcap.clear();
//     if ( qcap.size()!=wfms.get( *itch ).size() )
//       qcap.reserve( wfms.get( *itch ).size() );
//     qcap.push_back( 0.0 );
//     for ( unsigned int tdc=1; tdc<wfms.get( *itch ).size(); tdc++ ) {
//       double adc = wfms.get( *itch ).at( tdc );
//       double q = 50.0*adc/RC + f*qcap.at( tdc-1 );
//       qcap.push_back ( q );
//     }
    
//     // subtract correction
//     for ( unsigned int tdc=0; tdc<wfms.get( *itch ).size(); tdc++ ) {
//       wfms.get( *itch ).at( tdc ) -= qcap.at( tdc );
//     }
//   }
// }

// void SubEventBuilder::GetHitGeometryInfo(subevent::Flash const& flash,
// 					 geo::Geometry const& geom,
// 					 std::vector<double> & sumw,
// 					 std::vector<double> & sumw2,
// 					 double & sumy, double & sumy2,
// 					 double & sumz, double & sumz2)
// {
//   double xyz[3];
//   geom.OpDetGeoFromOpChannel( (unsigned int)flash.ch ).GetCenter(xyz);

//   double PEThisHit = flash.area;
//   for(size_t p=0; p!=geom.Nplanes(); p++){
//     unsigned int w = geom.NearestWire(xyz,p);
//     sumw.at(p)  += w*PEThisHit;
//     sumw2.at(p) += w*w*PEThisHit;
//   }
  
//   sumy+=xyz[1]*PEThisHit; sumy2+=xyz[1]*xyz[1]*PEThisHit;
//   sumz+=xyz[2]*PEThisHit; sumz2+=xyz[2]*xyz[2]*PEThisHit;
// }

// void SubEventBuilder::makeOpFlashes( art::Event& e, subevent::SubEventList& subevents, subevent::WaveformData& wfms ) {
  
//   art::ServiceHandle<util::TimeService> ts;
//   art::ServiceHandle<geo::Geometry> geom;
//   geo::Geometry const& Geometry(*geom);

//   std::unique_ptr< std::vector< recob::OpFlash > >  opflashes( new std::vector< recob::OpFlash > );
//   std::unique_ptr< std::vector< recob::OpHit > > ophits( new std::vector< recob::OpHit > );
//   std::unique_ptr< art::Assns<recob::OpFlash, recob::OpHit> >  AssnPtr( new art::Assns<recob::OpFlash, recob::OpHit> );

//   for ( subevent::SubEventListIter isubevent=subevents.begin(); isubevent!=subevents.end(); isubevent++ ) {
//     subevent::SubEvent& asubevent = (*isubevent);
//     // gather info to make an opflash for this subevent:
//     //
//     // OpFlash(double time, double timewidth, double abstime, unsigned int frame,
//     // 	    std::vector< double > PEperOpDet,
//     // 	    bool InBeamFrame=0, int OnBeamTime=0, double FastToTotal=1,
//     // 	    double yCenter=0, double yWidth=0,
//     // 	    double zCenter=0, double zWidth=0,
//     // 	    std::vector<double> WireCenters = std::vector<double>(0),
//     // 	    std::vector<double> WireWidths  = std::vector<double>(0));
//     double timestamp = wfms.getTimestamp(asubevent.flashes.get(0).ch); // us
//     double abstime = timestamp + asubevent.tmax_sample*ts->OpticalClock().TickPeriod(); // us
//     double reltime = abstime - ts->BeamGateTime(); // us
//     double width = ( asubevent.tend_sample - asubevent.tstart_sample )*ts->OpticalClock().TickPeriod(); // us
//     std::cout << "opflash: timestamp=" << timestamp << " us"
// 	      << " abstime=" << abstime << " us"
// 	      << " reltime=" << reltime << " us"  
// 	      << " width=" << width << " us" 
// 	      << " beamgatetime=" << ts->BeamGateTime() << " us"
// 	      << " tickperiod=" << ts->OpticalClock().TickPeriod() << " us" << std::endl;
//     // Emprical corrections to get the Frame right
//     // // Eventual solution - remove frames
//     // taken from OpFlashAlg.cxx
//     unsigned int frame = ts->OpticalClock().Frame( abstime );
//     unsigned int trigframe = ts->OpticalClock().Frame( ts->BeamGateTime() );
//     bool InBeamFrame = (frame==trigframe);
//     int OnBeamTime =0;
//     if( std::abs(reltime) < fTrigCoinc ) OnBeamTime=1; // this can't be right, can it?
//     double FastToTotal = 0.;

//     // geo stuff I copied
//     //std::vector<double> PEs(geom->MaxOpChannel()+1,0.0);
//     unsigned int Nplanes = geom->Nplanes();
//     std::vector<double> sumw(Nplanes,0), sumw2(Nplanes,0);
//     double sumy=0, sumz=0, sumy2=0, sumz2=0;
    
//     // sum pe for each opdet and do geo stuff
//     std::vector< double > PEperOpDet( geom->NOpDets(), 0.0 );
//     for ( subevent::FlashListIter iflash=asubevent.flashes.begin(); iflash!=asubevent.flashes.end(); iflash++ ) {
//       int iopdet = geom->OpDetFromOpChannel( (unsigned int)(*iflash).ch );
//       PEperOpDet.at( iopdet ) += (*iflash).area; // need calibration constants here
//       GetHitGeometryInfo( (*iflash), Geometry, sumw, sumw2, sumy, sumy2, sumz, sumz2 );
//     }
//     double meany = sumy/asubevent.totpe;
//     double meanz = sumz/asubevent.totpe;
//     double widthy  = sumy2*asubevent.totpe - sumy*sumy;
//     if ( widthy>0.0 )
//       widthy = sqrt( widthy );
//     else
//       widthy = 0.0;
//     double widthz = sumz2*asubevent.totpe - sumz*sumz;
//     if ( widthz>0.0 )
//       widthz = sqrt( widthz );
//     widthz = 0.0;

//     std::vector<double> WireCenters(Nplanes,0);
//     std::vector<double> WireWidths(Nplanes,0);
//     for(size_t p=0; p!=Nplanes; ++p){
//       WireCenters.at(p) = sumw.at(p)/asubevent.totpe;
//       WireWidths.at(p)  = sumw2.at(p)*asubevent.totpe - sumw.at(p)*sumw.at(p);
//       if ( WireWidths.at(p)> 0 ) WireWidths.at(p) = sqrt( WireWidths.at(p) );
//       else WireWidths.at(p) = 0.;
//     }

//     // finally, make the opflash
//     recob::OpFlash aopflash( reltime, width, abstime, frame, PEperOpDet, 
// 			     InBeamFrame, OnBeamTime, FastToTotal,
// 			     meany, widthy, meanz, widthz,
// 			     WireCenters, WireWidths );

//     // make ophits and associate it with the flashes
//     for ( subevent::FlashListIter iflash=asubevent.flashes.begin(); iflash!=asubevent.flashes.end(); iflash++ ) {
//       double flash_abstime = (*iflash).tmax*ts->OpticalClock().TickPeriod() + wfms.getTimestamp( (*iflash).ch );
//       double flash_reltime = flash_abstime -  ts->BeamGateTime();
//       unsigned int flash_frame = ts->OpticalClock().Frame( flash_abstime );
//       double flash_width = ( (*iflash).tend-(*iflash).tstart )*ts->OpticalClock().TickPeriod();
//       ophits->emplace_back( (int)(*iflash).ch, flash_reltime, flash_abstime, flash_frame, flash_width, (*iflash).area, (*iflash).maxamp, (*iflash).area/100.0, 0.0 ); // wants microseconds
//     }
//     opflashes->emplace_back( std::move( aopflash ) );
//   }//end of subevent loop
  
  
//   e.put( std::move( opflashes ) );
//   e.put( std::move( ophits ) );
//   e.put( std::move( AssnPtr ) );
  
// }

DEFINE_ART_MODULE(SubEventBuilder)
