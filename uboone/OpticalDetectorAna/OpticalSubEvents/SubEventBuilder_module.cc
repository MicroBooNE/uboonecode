////////////////////////////////////////////////////////////////////////
// Class:       SubEventBuilder
// Module Type: SubEventBuilder
// File:        SubEventBuilder_module.cc
//
// Generated at Thu Oct  8 13:18:22 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <set>
#include <map>
#include <vector>
#include <iostream>

// LArSoft
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/OpDetGeo.h"

#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/FlashList.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEvent.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventList.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventModule.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/SubEventModConfig.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/WaveformData.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/CosmicWindowSubEvents.hh"
#include "uboone/OpticalDetectorAna/OpticalSubEvents/subevent_algo/pedestal.hh"

class SubEventBuilder;

class SubEventBuilder : public art::EDProducer {
public:
  explicit SubEventBuilder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SubEventBuilder(SubEventBuilder const &) = delete;
  SubEventBuilder(SubEventBuilder &&) = delete;
  SubEventBuilder & operator = (SubEventBuilder const &) = delete;
  SubEventBuilder & operator = (SubEventBuilder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  std::string fOpDetInputModule;
  subevent::SubEventModConfig fConfig;
  bool fMakeOpFlash;
  bool fMakeSubEvents;
  bool fLightenFlashes;
  double fTrigCoinc;
  int fBeamWinLengthThreshold;
  int fChannelRangeMin;
  int fChannelRangeMax;
  bool fverbose;
  double fRC;
  double fA;

  bool sortWaveforms( art::Event& event, subevent::WaveformData& hgbeam, subevent::WaveformData& lgbeam, subevent::CosmicWindowHolder& cosmics, int beamwin_len_threshold );
  void prepCosmicDiscWaveforms(  subevent::CosmicWindowHolder& cosmics ); 
  void prepBeamWaveforms( art::Event& event, subevent::WaveformData& hgwfms, subevent::WaveformData& lgwfms, subevent::SubEventList& cosmic_subevents );
  void GetHitGeometryInfo(subevent::Flash const& flash,
  			  geo::GeometryCore const& geom,
  			  std::vector<double> & sumw,
  			  std::vector<double> & sumw2,
  			  double & sumy, double & sumy2,
  			  double & sumz, double & sumz2);
  void makeOpFlashes( art::Event& e, subevent::SubEventList& subevents, 
  		      std::vector< recob::OpFlash >&  opflashes,
  		      std::vector< recob::OpHit >& ophits,
  		      art::Assns<recob::OpFlash, recob::OpHit>& AssnPtr );
  void lightenFlashes( subevent::FlashList& flashes );
  
};


SubEventBuilder::SubEventBuilder(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{

  fOpDetInputModule           = p.get<std::string>( "inputModule");
  fMakeOpFlash                = p.get<bool>( "makeOpFlash", true );
  fMakeSubEvents              = p.get<bool>( "makeSubEvents", true );
  fLightenFlashes             = p.get<bool>( "lightenFlashes", false );
  fverbose                    = p.get<bool>( "verbose", true );
  fTrigCoinc                  = p.get<double>       ("TrigCoinc");
  fBeamWinLengthThreshold     = p.get<int>( "BeamWinLengthThreshold", 500 );
  fBeamWinLengthThreshold     = p.get<int>( "BeamWinLengthThreshold", 500 );
  fRC                         = p.get<double>( "RC", 60000.0 );
  fA                          = p.get<double>( "A", 3.0 );
  fChannelRangeMin            = p.get<int>("ChannelRangeMin", 0 );
  fChannelRangeMax            = p.get<int>("ChannelRangeMin", 31 );

  fConfig.cfdconfig.threshold = p.get<int>( "threshold" );
  fConfig.cfdconfig.deadtime  = p.get<int>( "deadtime" );
  fConfig.cfdconfig.delay     = p.get<int>( "delay" );
  fConfig.cfdconfig.width     = p.get<int>( "width" );
  fConfig.cfdconfig.gate      = p.get<int>( "gate" );
  fConfig.cfdconfig_pass2.threshold = p.get<int>( "pass2_threshold" );
  fConfig.cfdconfig_pass2.deadtime  = p.get<int>( "pass2_deadtime" );
  fConfig.cfdconfig_pass2.delay     = p.get<int>( "pass2_delay" );
  fConfig.cfdconfig_pass2.width     = p.get<int>( "pass2_width" );
  fConfig.cfdconfig_pass2.gate      = p.get<int>( "pass2_gate" );
  fConfig.fastfraction        = p.get<double>( "fastfraction", 0.8 );
  fConfig.slowfraction        = p.get<double>( "slowfraction", 0.3 );
  fConfig.fastconst_ns        = p.get<double>( "fastconst_ns", 6.0 );
  fConfig.slowconst_ns        = p.get<double>( "slowconst_ns", 1600.0 );
  fConfig.noslowthreshold     = p.get<double>( "noslowthreshold", 40.0 );
  fConfig.pedsamples          = p.get<int>( "pedsamples", 100 );
  fConfig.npresamples         = p.get<int>( "npresamples", 5 );
  fConfig.maxchflashes        = p.get<int>( "maxchflashes", 30 );
  fConfig.pedmaxvar           = p.get<double>( "pedmaxvar", 1.0 );
  fConfig.spe_sigma           = p.get< double >( "spe_sigma", 15.625*4.0 );
  fConfig.hgslot              = p.get<int>( "hgslot", 5 );
  fConfig.lgslot              = p.get<int>( "lgslot", 6 );
  fConfig.flashgate           = p.get<int>( "flashgate", 10 );
  fConfig.maxsubeventloops    = p.get<int>( "maxsubeventloops", 50 );
  fConfig.ampthresh           = p.get<double>( "ampthresh" );
  fConfig.hitthresh           = p.get<int>( "hitthresh" );
  fConfig.nspersample         = p.get<double>( "nspersample", 15.625 );

  // Call appropriate produces<>() functions here.
  if ( fMakeSubEvents ) {
    produces< std::vector< subevent::SubEvent > >();
    produces< subevent::FlashList >( "unclaimedFlashes" );
    produces< int >( "nbeamsubevents" );
    produces< int >( "ncosmicwindows" );
    //produces< int >( "nboundarysubevents" );
  }

  if ( fMakeOpFlash ) {
    produces<std::vector< recob::OpFlash> >();
    produces<std::vector< recob::OpHit> >();
    produces<art::Assns<recob::OpFlash, recob::OpHit> >();
  }
}

void SubEventBuilder::produce(art::Event & e)
{
  // Implementation of required member function here.  

  // get waveforms
  subevent::WaveformData hgwfms;
  subevent::WaveformData lgwfms;
  subevent::CosmicWindowHolder cosmicwins;
  bool ok = sortWaveforms( e, hgwfms, lgwfms, cosmicwins, fBeamWinLengthThreshold );
  if (!ok) {
    std::cout << "trouble loading waveforms!" << std::endl;
    return;
  }

  // We form subevents using just the cosmic discriminator windows
  subevent::SubEventList cosmic_subevents;
  prepCosmicDiscWaveforms( cosmicwins );
  subevent::formCosmicWindowSubEvents( cosmicwins, fConfig, cosmic_subevents );
  subevent::AnalyzeSubEvents( cosmic_subevents );
  if ( fverbose )
    std::cout << "Cosmic Disc. Subevents found: " << cosmic_subevents.size() << std::endl;
  // get waveforms and prep them
  prepBeamWaveforms( e, hgwfms, lgwfms, cosmic_subevents );

  // declare containers for beam subevent output
  subevent::SubEventList subevents;
  std::unique_ptr< subevent::FlashList > unclaimed_flashes( new subevent::FlashList() );

  // hack: make spe calibration table
  std::map< int, double > pmtspemap;
  for (int i=0; i<36; i++)
    pmtspemap[i] = 20.0;
  
  // Find subevents
  formSubEvents( hgwfms, fConfig, pmtspemap, subevents, *unclaimed_flashes );
  if ( fverbose )
    std::cout << "formed " << subevents.size() << " subevents. now store in event." << std::endl;
  
  // make opflash
  if ( fMakeOpFlash ) {

    std::unique_ptr< std::vector< recob::OpFlash > >  opflashes( new std::vector< recob::OpFlash > );
    std::unique_ptr< std::vector< recob::OpHit > > ophits( new std::vector< recob::OpHit > );
    std::unique_ptr< art::Assns<recob::OpFlash, recob::OpHit> >  AssnPtr( new art::Assns<recob::OpFlash, recob::OpHit> );

    makeOpFlashes( e, subevents, *opflashes, *ophits, *AssnPtr );
    makeOpFlashes( e, cosmic_subevents, *opflashes, *ophits, *AssnPtr );

    e.put( std::move( opflashes ) );
    e.put( std::move( ophits ) );
    e.put( std::move( AssnPtr ) );
    
  }

  if ( fMakeSubEvents ) {

    if ( fLightenFlashes ) {
      for ( subevent::SubEventListIter it=subevents.begin(); it!=subevents.end(); it++ ) {
	lightenFlashes( (*it).flashes );
	lightenFlashes( (*it).flashes_pass2 );
      }
      for ( subevent::SubEventListIter it=cosmic_subevents.begin(); it!=cosmic_subevents.end(); it++ ) {
	lightenFlashes( (*it).flashes );
	lightenFlashes( (*it).flashes_pass2 );
      }
      lightenFlashes( *unclaimed_flashes );
    }

    std::unique_ptr< int > NumBeamSubEvents( new int ); 
    std::unique_ptr< int > NumCosmicWindows( new int );
    (*NumBeamSubEvents) = subevents.size();
    (*NumCosmicWindows) = cosmic_subevents.size();

    // transfer subevents to the event
    std::unique_ptr< std::vector< subevent::SubEvent > > subeventvec( new std::vector< subevent::SubEvent > );
    for ( subevent::SubEventListIter it=subevents.begin(); it!=subevents.end(); it++ ) {
      (*it).runid = e.id().run();
      (*it).subrunid = e.id().subRun();
      (*it).eventid = e.id().event();
      subeventvec->emplace_back( *it );
    }
    for ( subevent::SubEventListIter it=cosmic_subevents.begin(); it!=cosmic_subevents.end(); it++ ) {
      (*it).runid = e.id().run();
      (*it).subrunid = e.id().subRun();
      (*it).eventid = e.id().event();
      subeventvec->emplace_back( *it );
    }
    
    e.put( std::move( subeventvec ) );
    e.put( std::move( NumBeamSubEvents ), "nbeamsubevents" );
    e.put( std::move( NumCosmicWindows ), "ncosmicwindows" );
    e.put( std::move( unclaimed_flashes ), "unclaimedFlashes" );
  }
  
}

bool SubEventBuilder::sortWaveforms( art::Event& event, subevent::WaveformData& hgbeam, subevent::WaveformData& lgbeam, subevent::CosmicWindowHolder& cosmics, int beamwin_len_threshold ) {
  // Load Services and Event Handles
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();
  
  art::Handle< std::vector< raw::OpDetWaveform > > hgwfmHandle;
  bool loadedhg = event.getByLabel( fOpDetInputModule, "OpdetBeamHighGain", hgwfmHandle );
  
  art::Handle< std::vector< raw::OpDetWaveform > > lgwfmHandle;
  bool loadedlg = event.getByLabel( fOpDetInputModule, "OpdetBeamLowGain", lgwfmHandle );
  if ( !loadedhg || !loadedlg ) {
    std::cout << "Could not load optdet waveforms!" << std::endl;
    return false;
  }

  // get trigger and beamgate info
  double trig_timestamp = ts->TriggerTime();
  if ( fverbose )
    std::cout << "[SubEventBuilder] trig timestamp: " << trig_timestamp << "  beam timestamp: " << ts->BeamGateTime() << " diff=" << ts->BeamGateTime()-trig_timestamp << std::endl;
  //unsigned int trig_frame = ts->OpticalClock().Frame( trig_timestamp );
  //unsigned int trig_sample = ts->OpticalClock().Sample( trig_timestamp );
  //double beam_timestamp = ts->BeamGateTime();
  //unsigned int beam_frame = ts->OpticalClock().Frame( beam_timestamp );
  //unsigned int beam_sample = ts->OpticalClock().Sample( beam_timestamp );

  // Loop over High-Gain Waveforms
  for ( auto const& opdetData: (*hgwfmHandle) ) {

    // get window info
    raw::Channel_t channel = opdetData.ChannelNumber()%100;
    double timestamp = opdetData.TimeStamp();      

    if ( (int)channel<fChannelRangeMin || (int)channel>fChannelRangeMax ) {
      if ( fverbose )
	std::cout << "[SubEventBuilder] skipping channel=" <<  channel << std::endl;
      continue;
    }

    if ( ((int)opdetData.size()) < beamwin_len_threshold ) {
      // cosmic windows: want to store ticks since trigger
      int ticks = (int)((timestamp - trig_timestamp)/ts->OpticalClock().TickPeriod());
      //std::cout << "cosmic window start=" << ticks << " (ticks)" << " len=" << (int)opdetData.size() << std::endl;
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      cosmics.addHG( (int)channel, ticks, wfm );
    }
    else {
      // beam windows: store timestamp
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      hgbeam.set( (int)channel, wfm, false );
      // store time stamp for later
      //std::cout << "beam window start=" << (opdetData.TimeStamp()-trig_timestamp)/ts->OpticalClock().TickPeriod() << " (ticks) len=" << (int)opdetData.size() << std::endl;
      hgbeam.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );
    }
  }

  // Loop over Low-Gain Waveforms
  for ( auto const& opdetData: (*lgwfmHandle) ) {

    // get window info
    raw::Channel_t channel = opdetData.ChannelNumber()%100;
    double timestamp = opdetData.TimeStamp();      

    if ( (int)channel<fChannelRangeMin || (int)channel>fChannelRangeMax ) {
      if ( fverbose )
	std::cout << "[SubEventBuilder] skipping channel=" <<  channel << std::endl;
      continue;
    }

    if ( ((int)opdetData.size()) < beamwin_len_threshold ) {
      // cosmic windows: want to store ticks since trigger
      int ticks = (int)((timestamp - trig_timestamp)/ts->OpticalClock().TickPeriod());
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      cosmics.addLG( (int)channel, ticks, wfm );
    }
    else {
      // beam windows: store timestamp
      std::vector< double > wfm;
      wfm.reserve( opdetData.size() );
      for ( auto adc: opdetData )
	wfm.push_back( (double)adc );
      lgbeam.set( (int)(channel), wfm, false );
      lgbeam.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );
    }
  }
  
  
  return true;
}
  
void SubEventBuilder::prepCosmicDiscWaveforms( subevent::CosmicWindowHolder& cosmics ) {
  // we sort, remove the pedestal, scale up low gain, and replace saturated high gain waveforms with low gain waveforms
  cosmics.sort();

  // prep low gain waveforms
  for ( subevent::CosmicWfmMapIter it=cosmics.lowGainWfmMap.begin(); it!=cosmics.lowGainWfmMap.end(); it++ ) {
    for ( std::vector<double>::iterator iadc=(*it).second.begin(); iadc!=(*it).second.end(); iadc++ ) {
      (*iadc) -= 2047.0; // remove pedestal;
      (*iadc) *= 10.0;   // scale up for low gain
    }
  } // end of lowgain loop

  // prep high gain waveforms
  for ( subevent::CosmicWfmMapIter it=cosmics.highGainWfmMap.begin(); it!=cosmics.highGainWfmMap.end(); it++ ) {
    // remove pedestal
    double maxadc = 0.0;
    for ( unsigned iadc=0; iadc<(*it).second.size(); iadc++ ) {
      (*it).second.at(iadc) -= 2047.0;
      if ( (*it).second.at(iadc) > maxadc ) {
	maxadc = (*it).second.at(iadc);
      }
      if ( maxadc > 2020.0 ) {
	break; // we can stop, because we will replace this waveform
      }
    }

    if ( maxadc>2020.0 ) {
      maxadc = 0;
      // switch to low gain waveform
      subevent::CosmicWinIndex lgindex = cosmics.getLGindexFromHG( (*it).first );
      std::vector< double >& lgwfm = cosmics.lowGainWfmMap[ lgindex ];
      // overwrite high gain
      (*it).second.clear();
      (*it).second.reserve( lgwfm.size() );
      for ( unsigned iadc=0; iadc<lgwfm.size(); iadc++ ) {
	(*it).second.push_back(lgwfm.at(iadc) );
	if ( lgwfm.at(iadc) > maxadc ) {
	  maxadc = lgwfm.at(iadc);
	}
      }
    }//if saturated, replace 
  }//end of high gain loop
} // end of prepCosmicDiscWaveforms

void SubEventBuilder::prepBeamWaveforms( art::Event& event, subevent::WaveformData& hgwfms, subevent::WaveformData& lgwfms, subevent::SubEventList& cosmicsubevents ) {
  // get services
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();

  // first replace hgwfms that saturate and remove pedestal. also calculate mean beam timestapm while we are at it
  double mean_hg_beamtimestamp = 0.;
  int hg_nchans = 0;
  for ( subevent::ChannelSetIter it=hgwfms.chbegin(); it!=hgwfms.chend(); it++ ) {
    if ( (*it)<32 ) {
      mean_hg_beamtimestamp  += hgwfms.getTimestamp( (*it) );
      hg_nchans++;
    }
    std::vector< double >& wfm = hgwfms.get( *it );
    bool replace = false;
    for ( auto adc : wfm ) {
      if ( adc > 4050 ) {
	replace = true;
	break;
      }
    }
    if ( replace ) {
      // remove low gain pedestal and scale by a factor of 10.0
      if ( fverbose )
	std::cout << " replaced hg channenl " << (*it) << "with lowgain channel." << std::endl;
      hgwfms.get( *it ).clear();
      std::vector< double >& lgwfm = lgwfms.get( *it );
      subevent::removePedestal( lgwfm, 20, 2.0, 2047.0 );
      hgwfms.get( *it ).reserve( lgwfm.size() );
      for ( auto adc : lgwfm )
	hgwfms.get( *it ).push_back( 10.0*adc );
      hgwfms.setLowGain( *it, true );
    }
    else {
      // remove high gain pedestal only
      subevent::removePedestal( hgwfms.get( *it ), 20.0, 2.0, 2047.0 );
    }
  } //end of channel loop
  
  // look for cosmic discriminator windows that cross into the boundary of the beam window
  subevent::SubEvent* boundarysubevent = NULL;
  mean_hg_beamtimestamp /= double(hg_nchans);
  double closest = 0;
  for ( subevent::SubEventListIter it=cosmicsubevents.begin(); it!=cosmicsubevents.end(); it++ ) {
    double dt_frombeamwin = (*it).tstart_sample*ts->OpticalClock().TickPeriod() - (mean_hg_beamtimestamp-ts->TriggerTime()); // cosmic window was from trigger time
    if ( -20.0 <= dt_frombeamwin && dt_frombeamwin < 0.0 ) {
      if (fverbose)
	std::cout << " found boundary subevent candidate:"
		  <<"  dt_frombeam=" << dt_frombeamwin << " usec (" << dt_frombeamwin/ts->OpticalClock().TickPeriod() << " ticks)"
		  << " tstart=" << (*it).tstart_sample 
		  << " tend=" << (*it).tend_sample << " (ticks)" << std::endl;
      if ( boundarysubevent==NULL || -dt_frombeamwin < closest ) {
	boundarysubevent = &(*it);
	closest = -dt_frombeamwin;
      }
    }
  }
  
  // if we found a boundary subevent, we correct the baseline
  std::map< int, int > baseline_correction_start;
  if ( boundarysubevent ) {
    if (fverbose)
      std::cout << "[SubEventBuilder] boundary subevent, "
		<< " tstart=" << (boundarysubevent->tstart_sample*ts->OpticalClock().TickPeriod()-(mean_hg_beamtimestamp-ts->TriggerTime()))/ts->OpticalClock().TickPeriod() << " (ticks from beamwin)"
		<< " tstart=" << boundarysubevent->tstart_sample
		<< " tend=" << boundarysubevent->tend_sample << " (ticks from trig)" << std::endl;
    double f = exp( -fConfig.nspersample/fRC );

    for ( subevent::FlashListIter iflash=boundarysubevent->flashes.begin(); iflash!=boundarysubevent->flashes.end(); iflash++ ) {
      int ch = (*iflash).ch;

      // calc correction: use the flash expectation, because we don't have the actual waveform unfortunately
      std::vector< double > vcorr( 1, 0.0 );
      for ( unsigned int iadc=1; iadc<(*iflash).expectation.size(); iadc++ ) {
	double q = (*iflash).expectation.at(iadc)*fA*(fConfig.nspersample/fRC) + vcorr.at( iadc-1 )*f;
	vcorr.push_back( q );
      }
      // extend until we fall below 1 adc
      unsigned int iadc = vcorr.size()-1;
      while ( vcorr.at(iadc) > 1.0 ) {
	double q = vcorr.at(iadc)*f;
	vcorr.push_back( q );
	iadc++;
      }

      // beam window waveform for this channel
      std::vector< double >& beamwin = hgwfms.get( ch );

      // get times in ticks
      int tflashstart_frombeam  = int( ((*iflash).tstart*ts->OpticalClock().TickPeriod()-(mean_hg_beamtimestamp-ts->TriggerTime()))/ts->OpticalClock().TickPeriod() );
      int tflashend_frombeam    = tflashstart_frombeam + (int)vcorr.size();
      int tbeamstart_fromcosmic = -tflashstart_frombeam;
      int tbeamend_fromcosmic   = tbeamstart_fromcosmic+(int)beamwin.size();

      // apply the correction if it enters the beam window
      if ( tflashend_frombeam>0 ) {
	int corrend = std::min( tbeamend_fromcosmic, (int)vcorr.size() ); // stop correction at end of beam window or at end of correction
	for ( int iadc=tbeamstart_fromcosmic; iadc<corrend; iadc++ ) {
	  if ( iadc-tbeamstart_fromcosmic < (int)beamwin.size() )
	    beamwin.at( iadc-tbeamstart_fromcosmic ) -= vcorr.at( iadc );
	}
	if ( !hgwfms.isLowGain( ch ) )
	  subevent::removePedestal( beamwin, 20.0, 2.0, 0.0 );
	else
	  subevent::removePedestal( beamwin, 20.0, 20.0, 0.0 );
	// we save where we stopped. this is so that baseline correction from charge inside beam window doesn't double count the correction we just made
	baseline_correction_start[ ch ] = std::min( tflashend_frombeam, (int)beamwin.size() );
      }// end of if correction reaches into beam window
    }//end of loop over flashes/channels
  }// end of if boundary event
  
  // baseline correct other waveforms
  double f = exp( -fConfig.nspersample/fRC );
  for ( subevent::ChannelSetIter it=hgwfms.chbegin(); it!=hgwfms.chend(); it++ ) {
    int ch = (*it);
    std::vector< double >& wfm = hgwfms.get( ch );
    // determine start of correction
    int correction_start = 1;
    if ( baseline_correction_start.find( ch )!=baseline_correction_start.end() )
      correction_start = baseline_correction_start[ch];
    if ( correction_start<1 )
      correction_start = 1;
    if ( correction_start >= (int)wfm.size() ) {
      // we've already corrected the entire waveform. skip this channel
      continue;
    }
    // calculate size of correction
    std::vector< double > vcorr( wfm.size(), 0.0 );
    for ( int iadc=correction_start; iadc<(int)vcorr.size(); iadc++ ) {
      double q = wfm.at( iadc )*fA*fConfig.nspersample/fRC + vcorr.at( iadc-1 )*f;
      vcorr.at( iadc ) = q;
    }
    // apply correction
    for ( int iadc=0; iadc<(int)wfm.size(); iadc++ )
      wfm.at(iadc) += vcorr.at( iadc );
  }// end of loop over hg channels
  
  // finally we want to suppress the creation of subevents within the bounds of the boundary subevents. we do this by removing the waveform here
  if ( boundarysubevent ) {
    int subevent_tend = boundarysubevent->tend_sample; // samples from trigger
    if ( fverbose )
      std::cout << "suppressing waveform from boundary subevent up to sample " << subevent_tend << " tend=" << boundarysubevent->tend_sample << " (ticks)" 
		<< " " << boundarysubevent->tend_sample*ts->OpticalClock().TickPeriod()*1.0e6
		<< " " << boundarysubevent->tend_sample*ts->OpticalClock().TickPeriod()*1.0e6 - ts->TriggerTime()
		<< std::endl;
    for ( subevent::FlashListIter iflash=boundarysubevent->flashes.begin(); iflash!=boundarysubevent->flashes.end(); iflash++ ) {
      int ch = (*iflash).ch;
      std::vector< double >& wfm = hgwfms.get( ch );
      int tflashend_frombeam = (int)(  ( (*iflash).tend*ts->OpticalClock().TickPeriod()-(mean_hg_beamtimestamp-ts->TriggerTime()) )/ts->OpticalClock().TickPeriod() );
      //int tbeamstart_fromflash = (int) ( ( (mean_hg_beamtimestamp-ts->TriggerTime())-(*iflash).tstart*ts->OpticalClock().TickPeriod() )/ts->OpticalClock().TickPeriod() );
      //std::cout << "  suppressing ch" << ch << " between 0 and " << tflashend_frombeam << " ticks in beam window (tick " << tbeamstart_fromflash << " of flash)" << std::endl;
      // suppress any portion of waveform that falls within this subevent
      if ( tflashend_frombeam>0 ) {
	int tend = std::min(tflashend_frombeam,(int)wfm.size());
  	double default_ped = wfm.at(tend);
	double ped = subevent::calcPedestal( wfm, 10, 1.0, default_ped );
  	for ( int iadc=0; iadc<tend; iadc++ ) {
	  // double flash_expectation = std::max( 0.0, (*iflash).expectation.at( tbeamstart_fromflash+iadc ) );
	  // double sig_exp = sqrt( flash_expectation );
	  // double adc = wfm.at(iadc);
	  // double diff = adc-ped;
	  // if ( diff < (flash_expectation + 3.0*sig_exp) )
	  wfm.at(iadc) = ped;
  	}
  	subevent::removePedestal( wfm, 20, 1.0, ped );
      }
    }
  }//end of suppression 
  
  hgwfms.calcBaselineInfo();
  lgwfms.calcBaselineInfo();

}

// bool SubEventBuilder::gatherWaveforms( art::Event& event, subevent::WaveformData& wfms, subevent::CosmicWindowHolder& cosmics ) {

//   // Load Services and Event Handles
//    auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();

//   art::Handle< std::vector< raw::OpDetWaveform > > hgwfmHandle;
//   bool loadedhg = event.getByLabel( fOpDetInputModule, "OpdetBeamHighGain", hgwfmHandle );
  
//   art::Handle< std::vector< raw::OpDetWaveform > > lgwfmHandle;
//   bool loadedlg = event.getByLabel( fOpDetInputModule, "OpdetBeamLowGain", lgwfmHandle );

//   if ( !loadedhg || !loadedlg ) {
//     std::cout << "Could not load optdet waveforms!" << std::endl;
//     return false;
//   }

//   // temp storage variables
//   std::vector< double > wfmstore;
//   std::set< int > use_lowgain_wfm;

//   // Loop over High-Gain Waveforms
//   unsigned int biggestcosmiclen = 0;
//   unsigned int beamwinlen = 0;
//   double shortestdt = 1e10;
//   for ( auto const& opdetData: (*hgwfmHandle) ) {
//     // if ( opdetData.size()<600 ) { // arbitrary!
//     //   // COSMIC WINDOW STORE
//     //   if ( opdetData.size()>biggestcosmiclen )
//     // 	biggestcosmiclen = opdetData.size();
//     //   //std::cout << "skipping cosmic window: " << opdetData.size() << std::endl;
//     //   double dtcosmic = opdetData.TimeStamp() - ts->BeamGateTime();
//     //   if ( fabs( dtcosmic )<shortestdt )
//     // 	shortestdt = fabs( dtcosmic );
//     //}

//     raw::Channel_t channel = opdetData.ChannelNumber();
//     wfmstore.clear();

//     if ( wfmstore.size() != opdetData.size() ) {
//       wfmstore.reserve( opdetData.size() );
//     }
//     if ( beamwinlen<opdetData.size() )
//       beamwinlen = opdetData.size();
      
//     bool marked_for_lg = false;
//     double adcmax = 0.0;
//     //std::cout << " ch " << channel << ": ";
//     for ( auto adc: opdetData ) {
//       if ( !marked_for_lg && adc>4090 ) {
// 	marked_for_lg = true;
// 	use_lowgain_wfm.insert( (int)channel );
//       }
//       wfmstore.push_back( (double)adc );
//       //std::cout << adc << " ";
//       if ( adcmax < (double)adc )
// 	adcmax = (double)adc;
//     }
//     //std::cout << std::endl;
//     //double ped =  subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
//     subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
//     //std::cout << "  adc max: " << adcmax-ped << " pedestal=" << ped << std::endl;
//     wfms.set( (int)channel, wfmstore, false );
//     // store time stamp for later
//     wfms.storeTimeInfo( (int)channel,  ts->OpticalClock().Frame( opdetData.TimeStamp() ), opdetData.TimeStamp() );

//     // Low-Gain Waveforms
//     if ( use_lowgain_wfm.size() > 0 ) {
//       for ( auto const& opdetData: (*lgwfmHandle) ) {
// 	if ( opdetData.size()<600 )
// 	  continue; // skip cosmic windows
// 	raw::Channel_t channel = opdetData.ChannelNumber();
// 	if ( use_lowgain_wfm.find( (int)channel )!=use_lowgain_wfm.end() ) {
// 	  // marked to replace hg
// 	  wfmstore.clear();
// 	  double adcmax = 0.0;
// 	  std::cout << " LG ch " << channel << ": ";
// 	  for ( auto adc: opdetData ) {
// 	    wfmstore.push_back( (double)adc );
// 	    if ( adcmax < (double)adc )
// 	      adcmax = (double)adc;
// 	  }
// 	  double ped = subevent::removePedestal( wfmstore, 20, 2.0, 2047.0 );
// 	  std::cout << "  adc max: " << 10.0*(adcmax-ped) << " pedestal=" << ped << std::endl;
	  
// 	  // scale up
// 	  for (int i=0; i<(int)wfmstore.size(); i++ )
// 	    wfmstore.at(i) *= 10.0;
	  
// 	  wfms.set( (int)channel, wfmstore, true ); // low gain waveform
// 	}// if marked for lg replacement
//       }// loop over lowgain waveforms
//     } // if replacements necessary

//     std::cout << "gathered beam waveforms: beamwin length=" << beamwinlen << " cosmicwin length=" << biggestcosmiclen << " shorteddt=" << shortestdt*1000 << " ns" << std::endl;
    
//   }
  
//   return true;
// }

// void SubEventBuilder::baselineCorrectWaveforms( subevent::WaveformData& wfms ) {
//   double RC = 50000.0; // ns
//   double f = exp( -15.625/RC );
//   std::vector< double > qcap;
  
//   for ( subevent::ChannelSetIter itch=wfms.chbegin(); itch!=wfms.chend(); itch++ ) {

//     // calc charge on capacitor
//     qcap.clear();
//     if ( qcap.size()!=wfms.get( *itch ).size() )
//       qcap.reserve( wfms.get( *itch ).size() );
//     qcap.push_back( 0.0 );
//     for ( unsigned int tdc=1; tdc<wfms.get( *itch ).size(); tdc++ ) {
//       double adc = wfms.get( *itch ).at( tdc );
//       double q = 50.0*adc/RC + f*qcap.at( tdc-1 );
//       qcap.push_back ( q );
//     }
    
//     // subtract correction
//     for ( unsigned int tdc=0; tdc<wfms.get( *itch ).size(); tdc++ ) {
//       wfms.get( *itch ).at( tdc ) -= qcap.at( tdc );
//     }
//   }
// }

void SubEventBuilder::GetHitGeometryInfo(subevent::Flash const& flash,
					 geo::GeometryCore const& geom,
					 std::vector<double> & sumw,
					 std::vector<double> & sumw2,
					 double & sumy, double & sumy2,
					 double & sumz, double & sumz2)
{
  double xyz[3];
  geom.OpDetGeoFromOpChannel( (unsigned int)flash.ch ).GetCenter(xyz);

  double PEThisHit = flash.area;
  for(size_t p=0; p!=geom.Nplanes(); p++){
    unsigned int w = geom.NearestWire(xyz,p);
    sumw.at(p)  += w*PEThisHit;
    sumw2.at(p) += w*w*PEThisHit;
  }
  
  sumy+=xyz[1]*PEThisHit; sumy2+=xyz[1]*xyz[1]*PEThisHit;
  sumz+=xyz[2]*PEThisHit; sumz2+=xyz[2]*xyz[2]*PEThisHit;
}

void SubEventBuilder::makeOpFlashes( art::Event& e, subevent::SubEventList& subevents, 
 				     std::vector< recob::OpFlash >&  opflashes,
 				     std::vector< recob::OpHit >& ophits,
 				     art::Assns<recob::OpFlash, recob::OpHit>& AssnPtr )
{
  
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();
  geo::GeometryCore const* geom = lar::providerFrom<geo::Geometry>();
  double dt_beam = ts->BeamGateTime() - ts->TriggerTime();

  for ( subevent::SubEventListIter isubevent=subevents.begin(); isubevent!=subevents.end(); isubevent++ ) {
    subevent::SubEvent& asubevent = (*isubevent);
    // gather info to make an opflash for this subevent:
    //
    // OpFlash(double time, double timewidth, double abstime, unsigned int frame,
    // 	    std::vector< double > PEperOpDet,
    // 	    bool InBeamFrame=0, int OnBeamTime=0, double FastToTotal=1,
    // 	    double yCenter=0, double yWidth=0,
    // 	    double zCenter=0, double zWidth=0,
    // 	    std::vector<double> WireCenters = std::vector<double>(0),
    // 	    std::vector<double> WireWidths  = std::vector<double>(0));
    double reltime = asubevent.tstart_sample*ts->OpticalClock().TickPeriod(); // us
    double abstime = ts->TriggerTime() + asubevent.tmax_sample*ts->OpticalClock().TickPeriod(); // us (both beam and cosmics measured relative to beginning of trigger
    double reltime_beam = reltime + dt_beam;
    double width = ( asubevent.tend_sample - asubevent.tstart_sample )*ts->OpticalClock().TickPeriod(); // us
    if ( fverbose )
      std::cout << "opflash: "
		<< " tsample_start=" << asubevent.tstart_sample << " tend_sample=" << asubevent.tend_sample
		<< " abstime=" << abstime << " us"
		<< " reltime=" << reltime << " us"  
		<< " width=" << width << " us" 
		<< " beamgatetime=" << ts->BeamGateTime() << " us"
		<< " tickperiod=" << ts->OpticalClock().TickPeriod() << " us" << std::endl;
    // Emprical corrections to get the Frame right
    // // Eventual solution - remove frames
    // taken from OpFlashAlg.cxx
    unsigned int frame = ts->OpticalClock().Frame( abstime );
    unsigned int trigframe = ts->OpticalClock().Frame( ts->BeamGateTime() );
    bool InBeamFrame = (frame==trigframe);
    int OnBeamTime =0;
    if( std::abs(reltime_beam) < fTrigCoinc ) OnBeamTime=1; // this can't be right, can it?
    double FastToTotal = 0.;

    // geo stuff I copied
    //std::vector<double> PEs(geom->MaxOpChannel()+1,0.0);
    unsigned int Nplanes = geom->Nplanes();
    std::vector<double> sumw(Nplanes,0), sumw2(Nplanes,0);
    double sumy=0, sumz=0, sumy2=0, sumz2=0;
    
    // sum pe for each opdet and do geo stuff
    std::vector< double > PEperOpDet( geom->NOpDets(), 0.0 );
    for ( subevent::FlashListIter iflash=asubevent.flashes.begin(); iflash!=asubevent.flashes.end(); iflash++ ) {
      // if ( (*iflash).ch>=32 )
      // 	std::cout << "weird channel: " << (*iflash).ch << std::endl;
      int iopdet = geom->OpDetFromOpChannel( (unsigned int)(*iflash).ch );
      // if ( iopdet >=32 )
      // 	std::cout << "weird opdet: " << iopdet << " " << (*iflash).ch << std::endl;
      PEperOpDet.at( iopdet ) += (*iflash).area; // need calibration constants here
      GetHitGeometryInfo( (*iflash), *geom, sumw, sumw2, sumy, sumy2, sumz, sumz2 );
    }
    double meany = sumy/asubevent.totpe;
    double meanz = sumz/asubevent.totpe;
    double widthy  = sumy2*asubevent.totpe - sumy*sumy;
    if ( widthy>0.0 )
      widthy = sqrt( widthy );
    else
      widthy = 0.0;
    double widthz = sumz2*asubevent.totpe - sumz*sumz;
    if ( widthz>0.0 )
      widthz = sqrt( widthz );
    widthz = 0.0;

    std::vector<double> WireCenters(Nplanes,0);
    std::vector<double> WireWidths(Nplanes,0);
    for(size_t p=0; p!=Nplanes; ++p){
      WireCenters.at(p) = sumw.at(p)/asubevent.totpe;
      WireWidths.at(p)  = sumw2.at(p)*asubevent.totpe - sumw.at(p)*sumw.at(p);
      if ( WireWidths.at(p)> 0 ) WireWidths.at(p) = sqrt( WireWidths.at(p) );
      else WireWidths.at(p) = 0.;
    }

    // finally, make the opflash
    recob::OpFlash aopflash( reltime, width, abstime, frame, PEperOpDet, 
			     InBeamFrame, OnBeamTime, FastToTotal,
			     meany, widthy, meanz, widthz,
			     WireCenters, WireWidths );

    // make ophits and associate it with the flashes
    for ( subevent::FlashListIter iflash=asubevent.flashes.begin(); iflash!=asubevent.flashes.end(); iflash++ ) {
      double flash_reltime = (*iflash).tmax*ts->OpticalClock().TickPeriod();
      double flash_abstime = flash_reltime + ts->TriggerTime();
      unsigned int flash_frame = ts->OpticalClock().Frame( flash_abstime );
      double flash_width = ( (*iflash).tend-(*iflash).tstart )*ts->OpticalClock().TickPeriod();
      //ophits->emplace_back( (int)(*iflash).ch, flash_reltime, flash_abstime, flash_frame, flash_width, (*iflash).area, (*iflash).maxamp, (*iflash).area/100.0, 0.0 ); // wants microseconds
      ophits.emplace_back( (int)(*iflash).ch, flash_reltime, flash_abstime, flash_frame, flash_width, (*iflash).area, (*iflash).maxamp, (*iflash).area/130.0, 0.0 ); // wants microseconds
    }
    opflashes.emplace_back( std::move( aopflash ) );
  }//end of subevent loop
  
}

void SubEventBuilder::lightenFlashes( subevent::FlashList& flashes ) {
  // doesn't seem to work
  for ( subevent::FlashListIter it=flashes.begin(); it!=flashes.end(); it++ ) {
    (*it).waveform.clear();
    (*it).expectation.clear();
    //std::vector<double>().swap( (*it).waveform );
    //std::vector<double>().swap( (*it).expectation );
  }
}



DEFINE_ART_MODULE(SubEventBuilder)
