////////////////////////////////////////////////////////////////////////
// Class:       UBBasicOpticalAna
// Module Type: analyzer
// File:        UBBasicOpticalAna_module.cc
//
// Generated at Mon Jun  1 04:51:40 2015 by Kazuhiro using artmod
// from cetpkgsupport v1_08_05.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "lardata/RawData/OpDetWaveform.h"
#include "OpDetWaveformAna.h"
#include "lardata/Utilities/TimeService.h"
#include <vector>
#include <string>

class UBBasicOpticalAna;

class UBBasicOpticalAna : public art::EDAnalyzer {
public:
  explicit UBBasicOpticalAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  UBBasicOpticalAna(UBBasicOpticalAna const &) = delete;
  UBBasicOpticalAna(UBBasicOpticalAna &&) = delete;
  UBBasicOpticalAna & operator = (UBBasicOpticalAna const &) = delete;
  UBBasicOpticalAna & operator = (UBBasicOpticalAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  void beginJob() override;

private:
  std::vector< std::string      > _module_v;    
  std::vector< bool             > _do_hitana_v;
  std::vector< bool             > _do_wfana_v;
  std::vector< bool             > _store_wf_v;
  std::vector< ::pmtana::OpDetWaveformAna > _ana_v;
  // Declare member data here.

};


UBBasicOpticalAna::UBBasicOpticalAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _module_v    = p.get< std::vector< std::string > > ( "InputModule"  );
  _do_hitana_v = p.get< std::vector< bool        > > ( "AnaHit"       );
  _do_wfana_v  = p.get< std::vector< bool        > > ( "AnaWaveform"  );
  _store_wf_v  = p.get< std::vector< bool        > > ( "SaveWaveform" );
  assert( _module_v.size () == _do_hitana_v.size () );
  assert( _module_v.size () == _do_wfana_v.size  () );
  assert( _module_v.size () == _store_wf_v.size  () );

  for(auto const& name : _module_v)
    _ana_v.emplace_back( name );
  
}

void UBBasicOpticalAna::beginJob()
{
  art::ServiceHandle<art::TFileService> fs;
  for(size_t i=0; i<_ana_v.size(); ++i) {
   
    
    if( _do_hitana_v [i] ) _ana_v[i].AnaHit       ( fs->make<TTree> ( Form( "hitana_%s_tree", _module_v[i].c_str() ), "" ) );
    if( _do_wfana_v  [i] ) _ana_v[i].AnaWaveform  ( fs->make<TTree> ( Form( "hitwf_%s_tree",  _module_v[i].c_str() ), "" ) );
    if( _store_wf_v  [i] ) _ana_v[i].SaveWaveform ( fs->make<TTree> ( Form( "wf_%s_tree",     _module_v[i].c_str() ), "" ) );

  }    
}

void UBBasicOpticalAna::analyze(art::Event const & e)
{
  art::ServiceHandle< util::TimeService > ts;

  // Implementation of required member function here.
  for(size_t i=0; i<_module_v.size(); ++i) {
   
    _ana_v[i].TickPeriod(ts->OpticalClock().TickPeriod());
 
    art::Handle< std::vector< raw::OpDetWaveform > > wf_handle;
    e.getByLabel( _module_v[i], wf_handle );

    if(!wf_handle.isValid()) continue;

    for(auto const& wf : *wf_handle) {
      if(!wf.size()) continue;
      _ana_v[i].AnaWaveform( wf.ChannelNumber(),
			     wf.TimeStamp() - ts->TriggerTime(),
			     wf );
    }
  }
}

DEFINE_ART_MODULE(UBBasicOpticalAna)
