////////////////////////////////////////////////////////////////////////
// Class:       OpHitFinder
// Module Type: producer
// File:        OpHitFinder_module.cc
//
// Generated at Thu Oct 22 08:47:09 2015 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "OpticalDetector/AlgoThreshold.h"
#include "OpticalDetector/AlgoFixedWindow.h"
#include "OpticalDetector/AlgoSlidingWindow.h"
#include "OpticalDetector/AlgoPedestal.h"
#include "OpticalDetector/PulseRecoManager.h"
#include "RecoBase/OpHit.h"
#include "Geometry/Geometry.h"
#include "Utilities/TimeService.h"
#include "RawData/OpDetWaveform.h"
#include <string>

class OpHitFinder;

class OpHitFinder : public art::EDProducer {
public:
  explicit OpHitFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpHitFinder(OpHitFinder const &) = delete;
  OpHitFinder(OpHitFinder &&) = delete;
  OpHitFinder & operator = (OpHitFinder const &) = delete;
  OpHitFinder & operator = (OpHitFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  pmtana::PulseRecoManager  _preco_mgr;
  std::string _producer;
  bool   _use_area;
  double _spe_size;
  bool _verbose;
  pmtana::PMTPulseRecoBase* _preco_alg;
  
};


OpHitFinder::OpHitFinder(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<recob::OpHit>   >();
  _producer = p.get<std::string>("OpDetWaveformProducer");
  _use_area = p.get<bool>("UseArea");
  _spe_size = p.get<double>("SPESize");

  _verbose  = p.get<bool>("Verbosity");

  _preco_mgr.SetPedAlgo(pmtana::kHEAD);
  _preco_mgr.SePedSampleCosmic (  3 );
  _preco_mgr.SetPedSampleBeam  ( 10 );

  auto const pset = p.get<fhicl::ParameterSet>("HitAlgoPset");

  std::string hit_alg_name = pset.get<std::string>("HitFinder");

  if(hit_alg_name == "Threshold")
    _preco_alg = new pmtana::AlgoThreshold(pset);
  else if(hit_alg_name == "FixedWindow")
    _preco_alg = new pmtana::AlgoFixedWindow(pset);
  else if(hit_alg_name == "SlidingWindow")
    _preco_alg = new pmtana::AlgoSlidingWindow(pset);

  _preco_mgr.AddRecoAlgo(_preco_alg);
  
}

void OpHitFinder::produce(art::Event & e)
{
  // Implementation of required member function here.
  std::unique_ptr< std::vector<recob::OpHit> > ophits(new std::vector<recob::OpHit>);
  
  art::Handle< std::vector< raw::OpDetWaveform > > wfHandle;
  e.getByLabel("pmtreadout", "OpdetBeamHighGain", wfHandle);
  if (!wfHandle.isValid()) {
    std::cerr<<"\033[93mInvalid Producer name: \033[00m"<<_producer.c_str()<<std::endl;
    throw std::exception();
  }

  art::ServiceHandle<geo::Geometry> geom;
  art::ServiceHandle<util::TimeService> ts;

  for(auto const& wf_ptr : *wfHandle) {

    const int Channel = (int)wf_ptr.ChannelNumber();
    const double TimeStamp = wf_ptr.TimeStamp();

    if(_verbose) std::cout << "Processing channel: " << Channel << std::endl;

    if(Channel>32) continue;

    if( !geom->IsValidOpChannel( Channel ) ) {
      mf::LogError("OpFlashFinder")<<"Error! unrecognized channel number " << Channel<<". Ignoring pulse";
      continue;
    }

    if(!_preco_mgr.RecoPulse(wf_ptr)) {

      std::cout << "\033[95m[WARNING]\033[00m PulseFinder algorithm returned invalid status! (Ch. " << Channel << ")" << std::endl;

    }

    const size_t NPulses = _preco_alg->GetNPulse();
    for(size_t k=0; k<NPulses; ++k){

      auto const& pulse = _preco_alg->GetPulse(k);

      double AbsTime = TimeStamp + pulse.t_max * ts->OpticalClock().TickPeriod();

      double RelTime = AbsTime - ts->BeamGateTime();
      if(ts->BeamGateTime()<0)
	RelTime = AbsTime - ts->TriggerTime();

      int    Frame   = ts->OpticalClock().Frame(TimeStamp);

      double PE      = 0.0;
      if (_use_area) PE = pulse.area / _spe_size;
      else           PE = pulse.peak / _spe_size;

      double width   = ( pulse.t_end - pulse.t_start ) * ts->OpticalClock().TickPeriod();

      ophits->emplace_back( Channel, RelTime, AbsTime, Frame, width, pulse.area, pulse.peak, PE, 0. );
    }
  }
  e.put(std::move(ophits));
}

DEFINE_ART_MODULE(OpHitFinder)
