////////////////////////////////////////////////////////////////////////
// Class:       OpHitFinder
// Module Type: producer
// File:        OpHitFinder_module.cc
//
// Generated at Thu Oct 22 08:47:09 2015 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "larana/OpticalDetector/OpHitFinder/AlgoThreshold.h"
#include "larana/OpticalDetector/OpHitFinder/AlgoFixedWindow.h"
#include "larana/OpticalDetector/OpHitFinder/AlgoSlidingWindow.h"
#include "larana/OpticalDetector/OpHitFinder/AlgoCFD.h"
#include "larana/OpticalDetector/OpHitFinder/PedAlgoEdges.h"
#include "larana/OpticalDetector/OpHitFinder/PedAlgoRollingMean.h"
#include "larana/OpticalDetector/OpHitFinder/PedAlgoUB.h"
#include "larana/OpticalDetector/OpHitFinder/PulseRecoManager.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include <string>

class OpHitFinder;

class OpHitFinder : public art::EDProducer {
public:
  explicit OpHitFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpHitFinder(OpHitFinder const &) = delete;
  OpHitFinder(OpHitFinder &&) = delete;
  OpHitFinder & operator = (OpHitFinder const &) = delete;
  OpHitFinder & operator = (OpHitFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  pmtana::PulseRecoManager  _preco_mgr;
  std::string _producer;
  std::string _label;
  bool   _use_area;
  double _spe_size;
  bool _verbose;
  pmtana::PMTPulseRecoBase* _preco_alg;
  
};


OpHitFinder::OpHitFinder(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<recob::OpHit>   >();
  _producer = p.get<std::string>("OpDetWaveformProducer");
  _label    = p.get<std::string>("OpDetWaveformLabel");
  _use_area = p.get<bool>("UseArea");
  _spe_size = p.get<double>("SPESize");

  _verbose  = p.get<bool>("Verbosity");

  /*
  _preco_mgr.SetPedAlgo(pmtana::kHEAD);
  _preco_mgr.SePedSampleCosmic (  3 );
  _preco_mgr.SetPedSampleBeam  ( 10 );
  */

  auto const hit_alg_pset = p.get<fhicl::ParameterSet>("HitAlgoPset");
  std::string hit_alg_name = hit_alg_pset.get<std::string>("Name");
  if      (hit_alg_name == "Threshold")
    _preco_alg = new pmtana::AlgoThreshold(hit_alg_pset);
  //else if (hit_alg_name == "SiPM")
  //_preco_alg = new pmtana::AlgoSiPM(hit_alg_pset);
  else if (hit_alg_name == "SlidingWindow")
    _preco_alg = new pmtana::AlgoSlidingWindow(hit_alg_pset);
  else if (hit_alg_name == "FixedWindow")
    _preco_alg = new pmtana::AlgoFixedWindow(hit_alg_pset);
  else if (hit_alg_name == "CFD" )
    _preco_alg = new pmtana::AlgoCFD(hit_alg_pset);
  else throw art::Exception(art::errors::UnimplementedFeature)
	 << "Cannot find implementation for "
	 << hit_alg_name << " algorithm.\n";
  _preco_mgr.AddRecoAlgo(_preco_alg);

  auto const ped_alg_pset = p.get<fhicl::ParameterSet>("PedAlgoPset");
  std::string ped_alg_name = ped_alg_pset.get<std::string>("Name");
  if      (ped_alg_name == "Edges")
    _preco_mgr.SetDefaultPedAlgo(new pmtana::PedAlgoEdges(ped_alg_pset));
  else if (ped_alg_name == "RollingMean")
    _preco_mgr.SetDefaultPedAlgo(new pmtana::PedAlgoRollingMean(ped_alg_pset));
  else if (ped_alg_name == "UB"   )
    _preco_mgr.SetDefaultPedAlgo(new pmtana::PedAlgoUB(ped_alg_pset));
  
}

void OpHitFinder::produce(art::Event & e)
{
  // Implementation of required member function here.
  std::unique_ptr< std::vector<recob::OpHit> > ophits(new std::vector<recob::OpHit>);
  
  art::Handle< std::vector< raw::OpDetWaveform > > wfHandle;
  if(_label.empty())
    e.getByLabel(_producer, wfHandle);
  else
    e.getByLabel(_producer,_label,wfHandle);
  if (!wfHandle.isValid()) {
    std::cerr<<"\033[93mInvalid Producer name: \033[00m"<<_producer.c_str()<<std::endl;
    throw std::exception();
  }

  art::ServiceHandle<geo::Geometry> geom;
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();

  for(auto const& wf_ptr : *wfHandle) {

    const int Channel = (int)wf_ptr.ChannelNumber();
    const double TimeStamp = wf_ptr.TimeStamp();

    if(_verbose) std::cout << "Processing channel: " << Channel << std::endl;

    if(Channel>32) continue;

    if( !geom->IsValidOpChannel( Channel ) ) {
      mf::LogError("OpFlashFinder")<<"Error! unrecognized channel number " << Channel<<". Ignoring pulse";
      continue;
    }

    if(!_preco_mgr.Reconstruct(wf_ptr)) {

      std::cout << "\033[95m[WARNING]\033[00m PulseFinder algorithm returned invalid status! (Ch. " << Channel << ")" << std::endl;

    }

    const size_t NPulses = _preco_alg->GetNPulse();
    for(size_t k=0; k<NPulses; ++k){

      auto const& pulse = _preco_alg->GetPulse(k);

      double AbsTime = TimeStamp + pulse.t_max * ts->OpticalClock().TickPeriod();

      double RelTime = AbsTime - ts->BeamGateTime();
      if(ts->BeamGateTime()<0)
	RelTime = AbsTime - ts->TriggerTime();

      int    Frame   = ts->OpticalClock().Frame(TimeStamp);

      double PE      = 0.0;
      if (_use_area) PE = pulse.area / _spe_size;
      else           PE = pulse.peak / _spe_size;

      double width   = ( pulse.t_end - pulse.t_start ) * ts->OpticalClock().TickPeriod();

      ophits->emplace_back( Channel, RelTime, AbsTime, Frame, width, pulse.area, pulse.peak, PE, 0. );
    }
  }
  e.put(std::move(ophits));
}

DEFINE_ART_MODULE(OpHitFinder)
