////////////////////////////////////////////////////////////////////////
// Class:       OpDigitSaturationCorrection
// Module Type: producer
// File:        OpDigitSaturationCorrection_module.cc
//
// Generated at Sun Oct 25 16:07:45 2015 by David Caratelli using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// data-products
#include "RecoBase/OpHit.h"
#include "RawData/OpDetWaveform.h"
//#include "RawData/TriggerData.h"
#include "Utilities/DetectorClocksService.h" // lardata

// C++ includes
#include <memory>
#include <iostream>
#include <cmath>
#include <limits>	  

// ROOT includes
#include <TTree.h>

// function to get idx of max ADC from a wf
size_t getMaxADC(const std::vector<short>& wf){
  
  size_t max_idx = 0;
  short  max_adc = 0;
  for (size_t i=0; i < wf.size(); i++){
    if (wf.at(i) > max_adc){
      max_adc = wf.at(i);
      max_idx = i;
    }
  }// for all ADCs
  
  return max_idx;
}

class OpDigitSaturationCorrection;

class OpDigitSaturationCorrection : public art::EDProducer {
public:
  explicit OpDigitSaturationCorrection(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpDigitSaturationCorrection(OpDigitSaturationCorrection const &) = delete;
  OpDigitSaturationCorrection(OpDigitSaturationCorrection &&) = delete;
  OpDigitSaturationCorrection & operator = (OpDigitSaturationCorrection const &) = delete;
  OpDigitSaturationCorrection & operator = (OpDigitSaturationCorrection &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Verbosity setter
  void SetVerbose(bool on) { _verbose = on; }

private:

  // Declare member data here.

  // functions:
  size_t FindMatchingLGPulse(const unsigned int& chan, const double& time,
			     const std::vector<std::vector< std::pair<size_t,double> > >& LG_ChanMap);

  void MakeTree();

  // trigger time (usec)
  double _TrigTime;

  // time-tick duration in usec
  double _TDC;
  
  // by how much to scale LG so that it matches the HG?
  double _gain_fact;

  // max ADC
  short unsigned int ADC_max;

  // max IDX
  size_t IDX_max;

  // verbosity flag
  bool _verbose;

  // Flag to include beamgate
  bool _include_beamgate;

  // baseline?
  short unsigned int _baseline;

  // vector holding the calibration correction factors per PMT
  std::vector<double> _calibration_corr;

  // Waveform producer name
  std::string _lowgain_producer;
  std::string _lowgain_label;
  std::string _highgain_producer;
  std::string _highgain_label;

  // Tree variables
  TTree* _tree;
  int    _event;
  int    _subrun;
  int    _run;
  int    _chan;
  double _time_HG, _time_LG;
  int    _max_adc_HG, _max_adc_LG;
  int    _max_tdc_HG, _max_tdc_LG;
  int    _max_adc_corr; // the maximum ADC assigned to the LG corrected WF that replaced the HG saturated WF
};

size_t OpDigitSaturationCorrection::FindMatchingLGPulse(const unsigned int& chan, const double& time,
							const std::vector<std::vector< std::pair<size_t,double> > >& LG_ChanMap)
{

  // search the _LG_ChanMap for a pulse on this channel at approx. the same time
  if (LG_ChanMap.at(chan).size() == 0)
    return IDX_max;

  // HG_pulses:
  auto const& LG_pulses = LG_ChanMap.at(chan);
  
  // go through them and find one with a matching time
  for (auto const& pulse : LG_pulses){
    if ( fabs(pulse.second - time) < 2*_TDC){
      // we have found a matching pulse!
      if (_verbose)
	std::cout << "found a matching pulse for chan " << chan << " @ time " << time << std::endl;
      return pulse.first;
    }
  }// for all HG pulses
  return IDX_max;
}


OpDigitSaturationCorrection::OpDigitSaturationCorrection(fhicl::ParameterSet const & p)
  : _tree(nullptr)
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<raw::OpDetWaveform>   >();

  // load per-PMT calibration correction factors
  _calibration_corr = p.get< std::vector<double> > ( "CalibrationCorr" );
  // if we did not provide 32 values (one per PMT) raise an exception
  if(_calibration_corr.size() != 32) {
    std::cerr<<"\033[93m[ERROR]\033[00m Calibration Correction vector does not have 32 elements!"<<std::endl;
    throw std::exception();
  }

  // Take care of a beamgate if specified
  _include_beamgate = p.get<bool>("IncludeBeamgate");

  // time tick is 15.6 ns (in usec)
  _TDC = 0.0156;

  // scale LG to HG
  _gain_fact = 10.;

  // set baseline
  _baseline = 2048;

  // max ADC
  ADC_max = std::numeric_limits<short unsigned int>::max();

  // max IDX
  IDX_max = std::numeric_limits<size_t>::max();

  // verbosity flag
  _verbose = p.get<bool>("verbose");

  // make tree
  MakeTree();

  // producer name/labels
  _lowgain_producer  = p.get<std::string>( "LGProducer"  );
  _lowgain_label     = p.get<std::string>( "LGLabel","*" );
  _highgain_producer = p.get<std::string>( "HGProducer"  );
  _highgain_label    = p.get<std::string>( "HGLabel","*" );

}

void OpDigitSaturationCorrection::produce(art::Event & e)
{
  
  // update tree variables for this event
  _run    = e.id().run();
  _subrun = e.id().subRun();
  _event  = e.id().event();

  // produce OpDetWaveform data-product to be filled within module
  std::unique_ptr< std::vector<raw::OpDetWaveform> > corrected_wfs(new std::vector<raw::OpDetWaveform>);

  // load OpDetWaveform from High Gain raw data
  art::Handle<std::vector<raw::OpDetWaveform> > opwf_HG_v;
  e.getByLabel(_highgain_producer, _highgain_label, opwf_HG_v);
  // make sure hits look good
  if(!opwf_HG_v.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate HG OpDetWf!"<<std::endl;
    throw std::exception();
  }

  // load OpDetWaveform from Low Gain raw data
  art::Handle<std::vector<raw::OpDetWaveform> > opwf_LG_v;
  e.getByLabel(_lowgain_producer, _lowgain_label, opwf_LG_v);
  // make sure hits look good
  if(!opwf_LG_v.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate LG OpDetWf!"<<std::endl;
    throw std::exception();
  }

  // load trigger data
  auto const* ts = lar::providerFrom<util::DetectorClocksService>();

  // get the trigger time
  _TrigTime = ts->TriggerTime();

  // fill a vector (for LG):
  // [ pmt channel ] -> [ idx(wf1), idx(wf2), ...]
  // to quickly find the position of wach LG wf
  std::vector<std::vector< std::pair<size_t,double> > > LG_ChanMap;
  LG_ChanMap.clear();
  for (size_t pmt=0; pmt < 32; pmt++)
    LG_ChanMap.push_back( std::vector<std::pair<size_t,double> >() );
  for (size_t idx = 0; idx < opwf_LG_v->size(); idx++){
    auto const& wf_LG = opwf_LG_v->at(idx);
    // ignore PMTs with channel number > 32
    if ( (wf_LG.ChannelNumber() >= 132) or (wf_LG.ChannelNumber() < 100) )
      continue;
    // ignore PMTs with size != cosmic discriminator size
    if (!_include_beamgate && wf_LG.size() > 800)
      continue;
    // LG indx = ChannelNumber() - 100 (to match HG channel number)
    double wf_time = wf_LG.TimeStamp() - _TrigTime;
    LG_ChanMap.at(wf_LG.ChannelNumber()-100).push_back( std::make_pair(idx,wf_time) );
  }

  // now loop through HG waveforms
  // if any one saturates
  // find the corresponding LG waveform
  // if available
  // append to the list of new WFs
  // either the un-saturated HG ones
  // or the corrected LG ones

  // loop through HG waveforms
  for(auto const& wf_HG : *opwf_HG_v){

    // ignore PMTs with channel number > 32
    if (wf_HG.ChannelNumber() >= 32)
      continue;
    // ignore PMTs with size != cosmic discriminator size
    if (!_include_beamgate && wf_HG.size() > 800)
      continue;

    if (_verbose)
      std::cout << "Starting a new HG wf" << std::endl;

    _time_LG = -1;
    _max_adc_LG = _max_tdc_LG = -1;
    _max_adc_corr = -1;
    
    auto const& max_idx = getMaxADC(wf_HG);
    double wf_time = wf_HG.TimeStamp() - _TrigTime;
    _time_HG    = wf_time;
    _max_adc_HG = wf_HG.at(max_idx) - _baseline;
    _max_tdc_HG = max_idx;
    _chan       = wf_HG.ChannelNumber();

    if (_verbose)
      std::cout << "This HG channel has Ch Num : " << wf_HG.ChannelNumber()
		<< " w/ TimeStamp : " << wf_time
		<< " w/ size : " << wf_HG.size() << std::endl
		<< "\t max ADC @ " << max_idx << " is " << wf_HG.at(max_idx) << std::endl;

    // find matching LG channel
    if (_verbose)
      std::cout << "Try and find a matching LG pulse" << std::endl;
    auto const& LG_idx = FindMatchingLGPulse(wf_HG.ChannelNumber(), wf_time, LG_ChanMap);

    // if we did not find a match:
    // add the old HG waveform
    if (LG_idx == IDX_max){
      if (_verbose)
	std::cout << "no match found -> add saturated HG wf" << std::endl;
      corrected_wfs->push_back(wf_HG);
    }

    else{
      // if we made it this far -> we found a match in LG information!
      if (_verbose)
	std::cout << "getting corresponding LG pulse w/ idx " << LG_idx << std::endl;
      auto const& wf_LG = opwf_LG_v->at(LG_idx);
      auto const& max_idx_LG = getMaxADC(wf_LG);
      _time_LG      = wf_LG.TimeStamp() - _TrigTime;
      _max_adc_LG   = wf_LG.at(max_idx_LG) - _baseline;
      _max_tdc_LG   = max_idx_LG;
      _max_adc_corr = _max_adc_LG * (_gain_fact*_calibration_corr[wf_LG.ChannelNumber()-100]);
      if (_verbose)
	std::cout << "finished getting corresponding LG pulse w/ idx " << LG_idx << std::endl;
      
      // if the max ADC value for the HG was below saturation -> add the HG wf
      if (_max_adc_HG < (4095-_baseline) ){
	if (_verbose)
	  std::cout << "HG pulse not saturated -> add HG pulse" << std::endl;
	corrected_wfs->push_back(wf_HG);
      }
      else{
	if (_verbose)
	  std::cout << "found a match and HG saturates! -> add LG wf w/ correction" << std::endl;
	// create a new waveform by editing the LG one
	if (_verbose)
	  std::cout << "corr factor for chan " << wf_LG.ChannelNumber()-100 
		    << " : " << _calibration_corr[wf_LG.ChannelNumber()-100] << std::endl;
	std::vector<short unsigned int> adcs;
	for (size_t n=0; n < wf_LG.size(); n++){
	  int this_ADC_above_baseline = wf_LG.at(n) - _baseline;
	  // make sure we don't overflow the data-product (not the firmware waveform...)
	  if (this_ADC_above_baseline > (int)( ADC_max / (_gain_fact*_calibration_corr[wf_LG.ChannelNumber()-100]) ) ){
	    if (_verbose) std::cout << "new ADC (saturated) : " << ADC_max << std::endl;
	    adcs.push_back(ADC_max);
	  }
	  else{
	    short unsigned int new_ADC = (short unsigned int)( this_ADC_above_baseline * (_gain_fact*_calibration_corr[wf_LG.ChannelNumber()-100]) + _baseline );
	    if (_verbose) std::cout << "new ADC (not saturated) : " << new_ADC << std::endl;
	    adcs.push_back( new_ADC );
	  }
	}// for all ADCs
	raw::OpDetWaveform new_wf(wf_LG.TimeStamp(),
				  wf_LG.ChannelNumber()-100,
				  adcs);
	corrected_wfs->push_back(new_wf);
      }// if this waveform saturates
    }// if LG wf was found
    
    if (_verbose)
      std::cout << "fill tree!" << std::endl;
    if (_tree) _tree->Fill();
    
    if (_verbose)
      std::cout << "move to next wf..." << std::endl;
    
  }// for all WFs
  
  /*
  // loop through LG waveforms
  for(auto const& wf : *opwf_LG_v){
    
    auto const& max_idx = getMaxADC(wf);
    
    if (_verbose)
      std::cout << "This LG channel has Ch Num : " << wf.ChannelNumber()
		<< " w/ TimeStamp : " << wf.TimeStamp() - _TrigTime 
		<< " w/ size : " << wf.size() << std::endl
		<< "\t max ADC @ " << max_idx << " is " << wf.at(max_idx) << std::endl;
  }
  */
  if (_verbose)
    std::cout << "done with this event" << std::endl;

  e.put(std::move(corrected_wfs));
  
}

void OpDigitSaturationCorrection::MakeTree()
{
  art::ServiceHandle<art::TFileService> tfs;
  _tree = tfs->make<TTree>("saturation_tree","Saturation Correction Tree");
  
  // Simple type branch
  _tree->Branch ( "run",        &_run,        "run/i"       );
  _tree->Branch ( "subrun",     &_subrun,     "subrun/i"    );
  _tree->Branch ( "event",      &_event,      "event/i"     );
  _tree->Branch ( "chan",       &_chan,       "chan/i"      );
  _tree->Branch ( "time_HG",    &_time_HG,    "time_HG/D"   );
  _tree->Branch ( "max_adc_HG", &_max_adc_HG, "max_adc_HG/I");
  _tree->Branch ( "max_tdc_HG", &_max_tdc_HG, "max_tdc_HG/I");
  _tree->Branch ( "time_LG",    &_time_LG,    "time_LG/D"   );
  _tree->Branch ( "max_adc_LG", &_max_adc_LG, "max_adc_LG/I");
  _tree->Branch ( "max_tdc_LG", &_max_tdc_LG, "max_tdc_LG/I");
  _tree->Branch ( "max_adc_corr", &_max_adc_corr, "max_adc_corr/I");

}

DEFINE_ART_MODULE(OpDigitSaturationCorrection)
