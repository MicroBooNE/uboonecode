////////////////////////////////////////////////////////////////////////
// Class:       OpDigitSaturationCorrection
// Module Type: producer
// File:        OpDigitSaturationCorrection_module.cc
//
// Generated at Sun Oct 25 16:07:45 2015 by David Caratelli using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// data-products
#include "RecoBase/OpHit.h"
#include "RawData/OpDetWaveform.h"
#include "RawData/TriggerData.h"

// C++ includes
#include <memory>
#include <iostream>
#include <cmath>
#include <limits>	  

// ROOT includes
#include <TTree.h>

// function to get idx of max ADC from a wf
size_t getMaxADC(const std::vector<short>& wf){
  
  size_t max_idx = 0;
  short  max_adc = 0;
  for (size_t i=0; i < wf.size(); i++){
    if (wf.at(i) > max_adc){
      max_adc = wf.at(i);
      max_idx = i;
    }
  }// for all ADCs
  
  return max_idx;
}

class OpDigitSaturationCorrection;

class OpDigitSaturationCorrection : public art::EDProducer {
public:
  explicit OpDigitSaturationCorrection(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpDigitSaturationCorrection(OpDigitSaturationCorrection const &) = delete;
  OpDigitSaturationCorrection(OpDigitSaturationCorrection &&) = delete;
  OpDigitSaturationCorrection & operator = (OpDigitSaturationCorrection const &) = delete;
  OpDigitSaturationCorrection & operator = (OpDigitSaturationCorrection &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Verbosity setter
  void SetVerbose(bool on) { _verbose = on; }

private:

  // Declare member data here.

  // functions:
  size_t FindMatchingLGPulse(const unsigned int& chan, const double& time,
			     const std::vector<std::vector< std::pair<size_t,double> > >& LG_ChanMap);

  void MakeTree();

  // trigger time (usec)
  double _TrigTime;

  // time-tick duration in usec
  double _TDC;
  
  // by how much to scale LG so that it matches the HG?
  double _gain_fact;

  // max ADC
  short unsigned int ADC_max;

  // max IDX
  size_t IDX_max;

  // verbosity flag
  bool _verbose;

  // baseline?
  short unsigned int _baseline;

  // Tree variables
  TTree* _tree;
  int    _event;
  int    _subrun;
  int    _run;
  int    _chan;
  double _time_HG, _time_LG;
  int    _max_adc_HG, _max_adc_LG;
  int    _max_tdc_HG, _max_tdc_LG;
};

size_t OpDigitSaturationCorrection::FindMatchingLGPulse(const unsigned int& chan, const double& time,
							const std::vector<std::vector< std::pair<size_t,double> > >& LG_ChanMap)
{

  // search the _LG_ChanMap for a pulse on this channel at approx. the same time
  if (LG_ChanMap.at(chan).size() == 0)
    return IDX_max;

  // HG_pulses:
  auto const& LG_pulses = LG_ChanMap.at(chan);
  
  // go through them and find one with a matching time
  for (auto const& pulse : LG_pulses){
    if ( fabs(pulse.second - time) < 2*_TDC){
      // we have found a matching pulse!
      if (_verbose)
	std::cout << "found a matching pulse for chan " << chan << " @ time " << time << std::endl;
      return pulse.first;
    }
  }// for all HG pulses
  return IDX_max;
}


OpDigitSaturationCorrection::OpDigitSaturationCorrection(fhicl::ParameterSet const & p)
  : _tree(nullptr)
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<raw::OpDetWaveform>   >();

  // time tick is 15.6 ns (in usec)
  _TDC = 0.0156;

  // scale LG to HG
  _gain_fact = 10.;

  // set baseline
  _baseline = 2048;

  // max ADC
  ADC_max = std::numeric_limits<short unsigned int>::max();

  // max IDX
  IDX_max = std::numeric_limits<size_t>::max();

  // verbosity flag
  _verbose = p.get<bool>("verbose");

  // make tree
  MakeTree();

}

void OpDigitSaturationCorrection::produce(art::Event & e)
{
  // produce OpDetWaveform data-product to be filled within module
  std::unique_ptr< std::vector<raw::OpDetWaveform> > corrected_wfs(new std::vector<raw::OpDetWaveform>);

  // load OpDetWaveform from High Gain raw data
  art::Handle<std::vector<raw::OpDetWaveform> > opwf_HG_v;
  e.getByLabel("pmtreadout", "OpdetBeamHighGain", opwf_HG_v);
  // make sure hits look good
  if(!opwf_HG_v.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate HG OpDetWf!"<<std::endl;
    throw std::exception();
  }

  // load OpDetWaveform from Low Gain raw data
  art::Handle<std::vector<raw::OpDetWaveform> > opwf_LG_v;
  e.getByLabel("pmtreadout", "OpdetBeamLowGain", opwf_LG_v);
  // make sure hits look good
  if(!opwf_LG_v.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate LG OpDetWf!"<<std::endl;
    throw std::exception();
  }

  // load trigger data
  art::Handle<std::vector<raw::Trigger> > trigger_v;
  e.getByLabel("daq", trigger_v);
  if(!trigger_v.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Trigger!"<<std::endl;
    throw std::exception();
  }

  // get the single trigger!
  const art::Ptr<::raw::Trigger> trigger_ptr(trigger_v,0);

  // get the trigger time
  _TrigTime = trigger_ptr->TriggerTime();

  // fill a vector (for LG):
  // [ pmt channel ] -> [ idx(wf1), idx(wf2), ...]
  // to quickly find the position of wach LG wf
  std::vector<std::vector< std::pair<size_t,double> > > LG_ChanMap;
  LG_ChanMap.clear();
  for (size_t pmt=0; pmt < 32; pmt++)
    LG_ChanMap.push_back( std::vector<std::pair<size_t,double> >() );
  for (size_t idx = 0; idx < opwf_LG_v->size(); idx++){
    auto const& wf_LG = opwf_LG_v->at(idx);
    if ( (wf_LG.ChannelNumber() >= 132) or (wf_LG.ChannelNumber() < 100) )
      continue;
    // LG indx = ChannelNumber() - 100 (to match HG channel number)
    double wf_time = wf_LG.TimeStamp() - _TrigTime;
    LG_ChanMap.at(wf_LG.ChannelNumber()-100).push_back( std::make_pair(idx,wf_time) );
  }

  // now loop through HG waveforms
  // if any one saturates
  // find the corresponding LG waveform
  // if available
  // append to the list of new WFs
  // either the un-saturated HG ones
  // or the corrected LG ones

  // loop through HG waveforms
  for(auto const& wf_HG : *opwf_HG_v){

    if (wf_HG.ChannelNumber() >= 32)
      continue;

    if (_verbose)
      std::cout << "Starting a new HG wf" << std::endl;

    _time_LG = -1;
    _max_adc_LG = _max_tdc_LG = -1;
    
    auto const& max_idx = getMaxADC(wf_HG);
    double wf_time = wf_HG.TimeStamp() - trigger_ptr->TriggerTime();
    _time_HG    = wf_time;
    _max_adc_HG = wf_HG.at(max_idx) - _baseline;
    _max_tdc_HG = max_idx;

    if (_verbose)
      std::cout << "This HG channel has Ch Num : " << wf_HG.ChannelNumber()
		<< " w/ TimeStamp : " << wf_time
		<< " w/ size : " << wf_HG.size() << std::endl
		<< "\t max ADC @ " << max_idx << " is " << wf_HG.at(max_idx) << std::endl;

    // find matching LG channel
    if (_verbose)
      std::cout << "Try and find a matching LG pulse" << std::endl;
    auto const& LG_idx = FindMatchingLGPulse(wf_HG.ChannelNumber(), wf_time, LG_ChanMap);

    // if we did not find a match:
    // add the old HG waveform
    if (LG_idx == IDX_max){
      if (_verbose)
	std::cout << "no match found -> add saturated HG wf" << std::endl;
      corrected_wfs->push_back(wf_HG);
    }

    else{
      // if we made it this far -> we found a match in LG information!
      if (_verbose)
	std::cout << "getting corresponding LG pulse w/ idx " << LG_idx << std::endl;
      auto const& wf_LG = opwf_LG_v->at(LG_idx);
      auto const& max_idx_LG = getMaxADC(wf_LG);
      _time_LG     = wf_LG.TimeStamp() - trigger_ptr->TriggerTime();
      _max_adc_LG = wf_LG.at(max_idx_LG) - _baseline;
      _max_tdc_LG = max_idx_LG;
      if (_verbose)
	std::cout << "finished getting corresponding LG pulse w/ idx " << LG_idx << std::endl;
      
      // if the max ADC value for the HG was below saturation -> add the HG wf
      if (_max_adc_HG <= 4095){
	if (_verbose)
	  std::cout << "HG pulse not saturated -> add HG pulse" << std::endl;
	corrected_wfs->push_back(wf_HG);
      }
      else{
	if (_verbose)
	  std::cout << "found a match and HG saturates! -> add LG wf w/ correction" << std::endl;
	// create a new waveform by editing the LG one
	std::vector<short unsigned int> adcs;
	for (size_t n=0; n < wf_LG.size(); n++){
	  short unsigned int this_ADC = wf_LG.at(n) - _baseline;
	  // make sure we don't overflow the data-product (not the firmware waveform...)
	  if (this_ADC > (short unsigned int)(ADC_max/_gain_fact) )
	    adcs.push_back(ADC_max);
	  else
	    adcs.push_back((short unsigned int)(this_ADC*_gain_fact));
	}// for all ADCs
	raw::OpDetWaveform new_wf(wf_LG.TimeStamp(),
				  wf_LG.ChannelNumber()-100,
				  adcs);
	corrected_wfs->push_back(new_wf);
      }// if this waveform saturates
    }// if LG wf was found
    
    if (_verbose)
      std::cout << "fill tree!" << std::endl;
    if (_tree) _tree->Fill();
    
    if (_verbose)
      std::cout << "move to next wf..." << std::endl;
    
  }// for all WFs
  
  /*
  // loop through LG waveforms
  for(auto const& wf : *opwf_LG_v){
    
    auto const& max_idx = getMaxADC(wf);
    
    if (_verbose)
      std::cout << "This LG channel has Ch Num : " << wf.ChannelNumber()
		<< " w/ TimeStamp : " << wf.TimeStamp() - trigger_ptr->TriggerTime() 
		<< " w/ size : " << wf.size() << std::endl
		<< "\t max ADC @ " << max_idx << " is " << wf.at(max_idx) << std::endl;
  }
  */
  if (_verbose)
    std::cout << "done with this event" << std::endl;

  e.put(std::move(corrected_wfs));
  
}

void OpDigitSaturationCorrection::MakeTree()
{
  art::ServiceHandle<art::TFileService> tfs;
  _tree = tfs->make<TTree>("saturation__tree","Saturation Correction Tree");
  
  // Simple type branch
  _tree->Branch ( "run",        &_run,        "run/i"       );
  _tree->Branch ( "subrun",     &_subrun,     "subrun/i"    );
  _tree->Branch ( "event",      &_event,      "event/i"     );
  _tree->Branch ( "chan",       &_chan,       "chan/i"      );
  _tree->Branch ( "time_HG",    &_time_HG,    "time_HG/D"   );
  _tree->Branch ( "max_adc_HG", &_max_adc_HG, "max_adc_HG/I");
  _tree->Branch ( "max_tdc_HG", &_max_tdc_HG, "max_tdc_HG/I");
  _tree->Branch ( "time_LG",    &_time_LG,    "time_LG/D"   );
  _tree->Branch ( "max_adc_LG", &_max_adc_LG, "max_adc_LG/I");
  _tree->Branch ( "max_tdc_LG", &_max_tdc_LG, "max_tdc_LG/I");

}

DEFINE_ART_MODULE(OpDigitSaturationCorrection)
