////////////////////////////////////////////////////////////////////////
// Class:       SimpleFlashFinder
// Module Type: producer
// File:        SimpleFlashFinder_module.cc
//
// Generated at Fri Oct  9 18:52:10 2015 by David Caratelli using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// data-products
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/RecoBase/OpFlash.h"

#include <memory>
#include <iostream>

// function that given a vector of charge on the PMTs
// returns the total charge on all PMTs
double TotalCharge(const std::vector<double>& PEs){
  double totalPE = 0.;
  for (auto const& pe : PEs)
    totalPE += pe;

  return totalPE;
}

class SimpleFlashFinder;

class SimpleFlashFinder : public art::EDProducer {
public:
  explicit SimpleFlashFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SimpleFlashFinder(SimpleFlashFinder const &) = delete;
  SimpleFlashFinder(SimpleFlashFinder &&) = delete;
  SimpleFlashFinder & operator = (SimpleFlashFinder const &) = delete;
  SimpleFlashFinder & operator = (SimpleFlashFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  std::string fOpHitProducer;

  // Get list of channel numbers for LG PMTs
  std::vector<int> fHGPMTChannels;

  // minimum PE to make a flash
  double _PE_min_flash;
  // minimum PE to use an OpHit
  double _PE_min_hit;
  // bin-width in time
  double _bin_width;

};


SimpleFlashFinder::SimpleFlashFinder(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  produces< std::vector<recob::OpFlash>   >();
  fOpHitProducer = p.get<std::string>("OpHitProducer");
  fHGPMTChannels = p.get<std::vector<int> >("HGPMTChannels");
  
  _PE_min_flash = 10;//50;
  _PE_min_hit   = 1;
  _bin_width = 0.1; // usec
}

void SimpleFlashFinder::produce(art::Event & e)
{

  // produce OpFlash data-product to be filled within module
  std::unique_ptr< std::vector<recob::OpFlash> > opflashes(new std::vector<recob::OpFlash>);

  // load OpHits previously created
  art::Handle<std::vector<recob::OpHit> > ophit_h;
  e.getByLabel(fOpHitProducer,ophit_h);
  // make sure hits look good
  if(!ophit_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate OpHit!"<<std::endl;
    throw std::exception();
  }

  // how to reconstruct OpFlashes:
  // divide the event in 100 ns windows
  // count up all the OpHits in each 100 ns window
  // and add up their charge
  // each 100 ns time-window will produce an OpFlash
  // provided > 0 PE are deposited in this time-window

  // only use the beam-gate window to find flashes
  // optical hit time boundaries now set and in usec
  double beam_gate = 23.4; // usec
  // how many 100 ns wide bins do we need?
  int n_bins = int(beam_gate/_bin_width)+1;
  
  
  // collect the total optical charge collected in the hits
  // in the various 100 ns-wide time slices
  std::vector< std::vector<double> > OpCharge(n_bins, std::vector<double>(fHGPMTChannels.size(),0.) );
  // find the peak-time for each 100-ns bin
  // this is the time at which the hit with the most PEs are found
  // vector of < time, PE of hit >
  // make sure we use the hit with the max PE
  std::vector<std::pair<double,double> > OpTime(n_bins, std::make_pair(0.,0.) );
  // total number of hits added:
  int nhits = 0;

  for(auto const& hit : *ophit_h) {


    // ignore hits with a channel number not in the list of HG PMT Channels
    // do modulo 100 to account for FEM board location
    std::vector<int>::iterator it;
    it = std::find( fHGPMTChannels.begin(), fHGPMTChannels.end(), hit.OpChannel() );
    // this PMT channels is not a HG PMT -> exit
    if (it == fHGPMTChannels.end() )
      continue;

    // ignore hits with < 5 PE
    if (hit.PE() < _PE_min_hit)
      continue;
    // figure out which 100-ns time bin this should go to
    double time = hit.PeakTime();
    
    int bin = int(time/_bin_width);


    if ( (bin >= n_bins) || (bin < 0) ){
      //std::cout << "we should not have a hit at this time! something is wrong" << std::endl;
      continue;
    }

    // get the channel number, modulo 100 [to remove FEM board dependency]
    int chmod = hit.OpChannel()%100;

    // if the entry number is out of range:
    if (chmod >= (int)OpCharge[bin].size())
      continue;

    // add the charge to the right bin and the right PMT
    OpCharge[bin][hit.OpChannel()] += hit.PE();
    nhits += 1;
    // if this hit has the largest charge -> adjust the flash's time
    if ( OpTime[bin].second < hit.PE() )
      OpTime[bin] = std::make_pair( hit.PeakTime(), hit.PE() );
  }// for all OpHits

  if (nhits == 0) {
    e.put(std::move(opflashes));
    return;
  }
  // try and take care of late-light:
  // if OpFlash charge in bin n+1 is
  // less then what is in bin n
  // merge the two together
  // seed bin (the one with highest light)
  size_t seed = 0;
  // vector of per-PMT PEs collected
  std::vector<double> PEperPMT(32,0.);
  // vector of indices to be cleared
  std::vector<size_t> to_clear;
  for (size_t i=0; i < OpCharge.size()-1; i++){
    // if a bin is larger than the previous -> it becomes the seed
    //std::cout << "tot charge " << i << " is  "<< TotalCharge(OpCharge.at(i)) << std::endl;
    //std::cout << "tot charge " << i+1 << " is " << TotalCharge(OpCharge.at(i+1)) << std::endl;
    if ( ( TotalCharge(OpCharge.at(i+1)) > TotalCharge(OpCharge.at(i)) ) and ( TotalCharge(OpCharge.at(i+1)) > 0) ){
      seed = i+1;
      //std::cout << "seed bin is " << seed << std::endl;
      // clear the bins to be emptied
      //std::cout << "clearing bins" << std::endl;
      for (auto& bin : to_clear)
	OpCharge[bin] = std::vector<double>(32,0.);
      //std::cout << "bins cleared" << std::endl;
      to_clear.clear();
    }
    // if a bin is lower than the previous one
    if ( ( TotalCharge(OpCharge.at(i+1)) < TotalCharge(OpCharge.at(i)) ) and ( TotalCharge(OpCharge.at(i+1)) > 0) ){
      // add to each PMT the light from the bin determined to be a "late-light" bin
      for (size_t pmt=0; pmt < 32; pmt++){
	//std::cout << "adding " << OpCharge.at(i+1)[pmt] << " to bin " << i << " for pmt " << pmt << std::endl;
	OpCharge[seed][pmt] += OpCharge.at(i+1)[pmt];
      }
      to_clear.push_back(i+1);
    }
  }// for all time-bins
  //std::cout << "done...create objects"  << std::endl;
  // now loop through the 100-ns windows and create flashes
  for (size_t i=0; i < OpCharge.size(); i++){
    if ( TotalCharge(OpCharge.at(i)) <= _PE_min_flash )
      continue;
    //std::cout << "create flash at time " << OpTime.at(i).first << std::endl;
    recob::OpFlash flash(OpTime.at(i).first,0.05,OpTime.at(i).first,0,OpCharge.at(i));
    opflashes->push_back(flash);
  }// for all 100 ns time-intervals


  e.put(std::move(opflashes));
  //std::cout << "done with the function" << std::endl;

}

DEFINE_ART_MODULE(SimpleFlashFinder)
