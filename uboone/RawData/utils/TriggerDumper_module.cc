////////////////////////////////////////////////////////////////////////
// Class:       TriggerDumper
// Module Type: analyzer
// File:        TriggerDumper_module.cc
//
// Generated at Wed Feb  3 14:50:01 2016 by Herbert Greenlee using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RawData/TriggerData.h"
#include "uboone/TriggerSim/UBTriggerTypes.h"
#include "uboone/RawData/utils/ubdaqSoftwareTriggerData.h"


class TriggerDumper;

class TriggerDumper : public art::EDAnalyzer {
public:
  explicit TriggerDumper(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TriggerDumper(TriggerDumper const &) = delete;
  TriggerDumper(TriggerDumper &&) = delete;
  TriggerDumper & operator = (TriggerDumper const &) = delete;
  TriggerDumper & operator = (TriggerDumper &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  // Fcl parameters.

  std::string fHardwareTriggerProducer;   // Hardware trigger module label.
  std::string fSoftwareTriggerProducer;   // Software trigger module label.
  int fNumDump;    // Number of events to dump.

  // Statistics.

  int fNumEvents;  // Number of events processed.
};


TriggerDumper::TriggerDumper(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fNumDump(0),
  fNumEvents(0)
{

  // Extract fcl parameters.

  fHardwareTriggerProducer = p.get<std::string>("HardwareTriggerProducer");
  fSoftwareTriggerProducer = p.get<std::string>("SoftwareTriggerProducer");
  fNumDump = p.get<int>("NumDump");

  // Report.

  mf::LogInfo("TriggerDumper") 
    << "TriggerDumper configured with the following parameters:\n"
    << "  Hardware trigger produder = " << fHardwareTriggerProducer << "\n"
    << "  Software trigger produder = " << fSoftwareTriggerProducer << "\n"
    << "  Number of events to dump = " << fNumDump;

}

void TriggerDumper::analyze(art::Event const & e)
{

  // Check whether we want to dump this event.

  ++fNumEvents;
  if(fNumEvents > fNumDump)
    return;

  // Do dump.

  mf::LogInfo log("TriggerDumper");

  // Dump hardware trigger bits.

  log << "\nHardware Trigger Information:\n";

  art::Handle<std::vector<raw::Trigger> > hh;
  e.getByLabel(fHardwareTriggerProducer, hh);
  if(hh.isValid()) {
    for(auto const& t : *hh) {
      log << "\n"
	  << "Trigger number: " << t.TriggerNumber() << "\n"
	  << "Trigger time:   " << t.TriggerTime() << "\n"
	  << "Beam gate time: " << t.BeamGateTime() << "\n"
	  << "Trigger bits:\n";
      unsigned int tbits = t.TriggerBits();
      for(int i=0; i<32; ++i) {
	if(tbits % 2 != 0) {
	  log << i << " - ";
	  if(i == trigger::kPMTTriggerBeam)
	    log << "PMTTriggerBeam";
	  if(i == trigger::kPMTTriggerCosmic)
	    log << "PMTTriggerCosmic";
	  if(i == trigger::kPMTTrigger)
	    log << "PMTTrigger";
	  if(i == trigger::kTriggerPC)
	    log << "TriggerPC";
	  if(i == trigger::kTriggerEXT)
	    log << "TriggerEXT";
	  if(i == trigger::kActive)
	    log << "Active";
	  if(i == trigger::kTriggerBNB)
	    log << "TriggerBNB";
	  if(i == trigger::kTriggerNuMI)
	    log << "TriggerNuMI";
	  if(i == trigger::kVeto)
	    log << "Veto";
	  if(i == trigger::kTriggerCalib)
	    log << "TriggerCalib";
	  if(i == trigger::kFakeGate)
	    log << "FakeGate";
	  if(i == trigger::kFakeBeam)
	    log << "FakeBeam";
	  if(i == trigger::kSpare)
	    log << "Spare";
	  log << "\n";
	}
	tbits = (tbits >> 1);
      }
    }
  }

  // Dump software triggers.

  log << "\nSoftware Trigger Information:\n\n";

  art::Handle<raw::ubdaqSoftwareTriggerData> sh;
  e.getByLabel(fSoftwareTriggerProducer, sh);
  if(sh.isValid()) {
    std::vector<std::string> algos = sh->getListOfAlgorithms();
    for(auto const& algo : algos) {
      bool pass_algo = sh->passedAlgo(algo);
      bool pass_prescale = sh->passedPrescaleAlgo(algo);
      log << algo << ": Algo: " << pass_algo << ": Prescale: " << pass_prescale << "\n";
    }
  }
}

DEFINE_ART_MODULE(TriggerDumper)
